<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vintage Photobooth + Private Memories</title>

  <!-- Leaflet (Map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>

  <style>
    :root{
      --paper:#f6f1e7;
      --ink:#171717;
      --muted:#6b6256;
      --accent:#6a4b2f;
      --shadow: 0 18px 50px rgba(0,0,0,.12);
      --radius: 18px;
      --line: rgba(0,0,0,.10);
      --danger:#b91c1c;
      --ok:#166534;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 600px at 50% 10%, #fff8ee 0%, var(--paper) 55%, #efe6d7 100%);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .shell{width:min(1120px,100%); display:grid; gap:14px;}
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 6px;
      flex-wrap:wrap;
    }
    .brand{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900; letter-spacing:.4px; font-size:22px;
      display:flex; gap:10px; align-items:baseline;
    }
    .hint{color:var(--muted); font-size:13px;}
    .tabs{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .tabBtn{
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.72);
      padding:10px 14px;
      font-size:13px;
      cursor:pointer;
    }
    .tabBtn.active{
      background:var(--accent);
      color:#fff;
      border-color: rgba(0,0,0,.12);
    }
    .tabBtn:disabled{opacity:.5; cursor:not-allowed;}

    .rightBar{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .sessionPill{
      display:flex; gap:8px; align-items:center;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.68);
      border-radius:999px;
      padding:7px 10px;
      font-size:12px;
      color:rgba(0,0,0,.78);
    }
    .dot{width:10px;height:10px;border-radius:999px;background:#999; box-shadow:0 6px 14px rgba(0,0,0,.10);}
    .dot.green{background:#16a34a;}
    .dot.red{background:#ef4444;}

    .card{
      background:rgba(255,255,255,.72);
      backdrop-filter: blur(8px);
      border:1px solid rgba(0,0,0,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .content{display:grid; grid-template-columns: 1.15fr .85fr; gap:0;}
    @media (max-width: 980px){ .content{grid-template-columns:1fr} }
    .stage{padding:18px; border-right:1px solid rgba(0,0,0,.06);}
    @media (max-width: 980px){ .stage{border-right:none;border-bottom:1px solid rgba(0,0,0,.06)} }
    .side{padding:18px; display:grid; gap:12px; align-content:start;}
    .panelTitle{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-size:18px; font-weight:900; margin:0 0 8px;
    }
    .sub{margin:0 0 12px; color:var(--muted); font-size:13px; line-height:1.45;}
    .previewWrap{
      background:rgba(255,255,255,.8);
      border:1px solid rgba(0,0,0,.08);
      border-radius:16px;
      padding:14px;
      display:grid;
      gap:10px;
    }
    video, canvas{
      width:100%;
      border-radius:14px;
      background:#000;
      display:block;
    }
    .controls{display:flex; gap:10px; flex-wrap:wrap;}
    button, select, input{
      border-radius: 14px;
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      padding:11px 12px;
      font-size:14px;
      outline:none;
    }
    button{cursor:pointer;}
    button.primary{background:#6a4b2f; color:#fff;}
    button.ghost{background:transparent;}
    button:disabled{opacity:.55; cursor:not-allowed;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.7);
      padding:7px 10px;
      border-radius:999px;
    }
    .countdown{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
      font-size:56px;
      line-height:1;
      color:rgba(26,26,26,.92);
      text-align:center;
      margin:8px 0 0;
      display:none;
    }
    .miniGrid{display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;}
    .thumb{
      border-radius:12px;
      border:1px solid rgba(0,0,0,.10);
      overflow:hidden;
      background:#000;
      aspect-ratio: 4/3;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block; opacity:.92;}
    .footerNote{
      padding:14px 18px;
      border-top:1px solid rgba(0,0,0,.06);
      color:var(--muted);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .metaGrid{display:grid; gap:10px;}
    .smallLabel{font-size:12px; color:var(--muted); margin:0 0 6px;}
    .chipRow{display:flex; gap:8px; flex-wrap:wrap;}
    .chip{
      border:1px solid var(--line);
      background:rgba(255,255,255,.7);
      color:rgba(26,26,26,.85);
      padding:7px 10px;
      border-radius:999px;
      font-size:12px;
      cursor:pointer;
    }
    .dangerBtn{
      border-color: rgba(220,38,38,.30);
      color:var(--danger);
      background:rgba(255,255,255,.85);
    }
    .mutedBtn{background:rgba(255,255,255,.85);}

    .modeTag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.72);
      font-size:12px;
      color:rgba(0,0,0,.75);
    }
    .modeDot{width:9px;height:9px;border-radius:999px;background:#999;}
    .modeDot.camera{background:#2563eb;}
    .modeDot.upload{background:#a16207;}

    /* Timeline */
    .timelineWrap{padding:18px;}
    .timelineHeader{
      display:flex; gap:12px; align-items:end; justify-content:space-between; flex-wrap:wrap;
      padding:6px 6px 14px;
      border-bottom:1px solid rgba(0,0,0,.06);
    }
    .timelineTitle{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900; font-size:20px;
    }
    .filters{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .filters input, .filters select{background:rgba(255,255,255,.8);}
    .timelineGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      padding:16px 6px 8px;
    }
    .tCard{
      position:relative;
      background:rgba(255,255,255,.82);
      border:1px solid rgba(0,0,0,.08);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 26px rgba(0,0,0,.09);
    }
    .tInner{display:grid; grid-template-columns: 220px 1fr;}
    @media (max-width: 760px){ .tInner{grid-template-columns: 1fr;} }
    .tThumb{
      background:#111;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:160px;
      border-right:1px solid rgba(0,0,0,.08);
    }
    @media (max-width: 760px){
      .tThumb{border-right:none;border-bottom:1px solid rgba(0,0,0,.08)}
    }
    .tThumb img{width:100%; height:100%; object-fit:cover; display:block; opacity:.95;}
    .tBody{padding:14px;}
    .tWhen{font-weight:800; font-size:14px;}
    .tWhere{color:var(--muted); font-size:12px; margin-top:6px; line-height:1.35;}
    .tPeople{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .pChip{
      border:1px solid rgba(0,0,0,.10);
      background:rgba(246,241,231,.8);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:rgba(26,26,26,.80);
    }
    .tActions{margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;}
     .tActions button{padding:10px 12px; font-size:13px; border-radius:12px;}
    .selWrap{position:absolute; top:10px; right:10px; display:flex; gap:8px; align-items:center;}
    .selWrap label{font-size:12px; color:rgba(0,0,0,.65); font-weight:800;}
    .selWrap input[type="checkbox"]{width:18px;height:18px; accent-color: var(--accent); cursor:pointer;}

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.72);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:rgba(0,0,0,.72);
      margin-top:10px;
    }
    .badge .bDot{
      width:9px;height:9px;border-radius:999px;background:var(--ok);
      box-shadow:0 6px 14px rgba(0,0,0,.10);
    }

    .timelineRail{position:relative; padding-left:34px;}
    .timelineRail::before{
      content:"";
      position:absolute;
      left:7px; top:0; bottom:0;
      width:2px;
      background:rgba(0,0,0,.06);
    }

    /* Map */
    #map { background:#eaeaea; }

    /* Modal */
    .modal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .modalCard{
      width:min(980px, 96vw);
      background:rgba(255,255,255,.92);
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:0 20px 60px rgba(0,0,0,.25);
    }
    .modalHead{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(0,0,0,.08);
    }
    .modalHead .title{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
    }
    .modalBody{padding:14px; background:#111;}
    .modalBody img{width:100%; height:auto; display:block;}

    /* Profile Gate */
    .gate{
      position:fixed; inset:0;
      background:radial-gradient(900px 500px at 50% 10%, rgba(255,248,238,.35), rgba(0,0,0,.62));
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:80;
    }
    .gateCard{
      width:min(920px, 96vw);
      background:rgba(255,255,255,.92);
      border-radius:18px;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:0 20px 60px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .gateHead{
      padding:14px 16px;
      border-bottom:1px solid rgba(0,0,0,.08);
      display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
    }
    .gateTitle{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
      font-size:18px;
    }
    .gateBody{
      padding:16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 820px){ .gateBody{grid-template-columns:1fr} }
    .box{
      border:1px solid rgba(0,0,0,.10);
      border-radius:16px;
      background:rgba(255,255,255,.75);
      padding:14px;
    }
    .profilesGrid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(2, minmax(0,1fr));
    }
    @media (max-width: 520px){ .profilesGrid{grid-template-columns:1fr} }
    .profileBtn{
      text-align:left;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.85);
      cursor:pointer;
    }
    .profileBtn .name{font-weight:900;}
    .profileBtn .meta{font-size:12px;color:rgba(0,0,0,.55);}

    /* Geo picker modal */
    .geoModal{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:70;
    }
    .geoCard{
      width:min(980px, 96vw);
      background:rgba(255,255,255,.92);
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:0 20px 60px rgba(0,0,0,.25);
    }
    .geoHead{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(0,0,0,.08);
    }
    .geoHead .title{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
    }
    .geoBody{padding:14px;}
    #geoPickMap{
      height:520px;
      border-radius:16px;
      border:1px solid rgba(0,0,0,.08);
      overflow:hidden;
      background:#eaeaea;
    }
  </style>
</head>

<body>
  <div class="shell">
    <div class="top">
      <div class="brand">
        <span>Vintage Photobooth</span>
        <span class="hint">Profiles + PIN → private timeline per person</span>
      </div>

      <div class="rightBar">
        <div class="sessionPill" id="sessionPill">
          <span id="statusDot" class="dot red"></span>
          <span id="sessionText">Guest (locked)</span>
        </div>
        <button id="switchProfileBtn" class="mutedBtn">Switch Profile</button>
        <button id="lockBtn" class="dangerBtn" style="display:none;">Lock</button>
      </div>

      <div class="tabs">
        <button id="tabBooth" class="tabBtn active">Photobooth</button>
        <button id="tabTimeline" class="tabBtn" disabled>Timeline</button>
      </div>
    </div>

    <div id="boothView" class="card">
      <div class="content">
        <div class="stage">
          <div class="previewWrap">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="out" width="1400" height="2000" style="display:none"></canvas>

            <div class="controls">
              <button id="startBtn" class="primary">Start Camera</button>
              <button id="flipBtn" class="ghost" disabled>Flip</button>
              <button id="shootBtn" class="primary" disabled>Take 3 Photos</button>
              <button id="uploadBtn" class="mutedBtn" disabled>Upload 3 Photos</button>
              <button id="retakeBtn" class="ghost" disabled>Reset</button>
              <button id="downloadBtn" class="primary" disabled>Download</button>
              <button id="printBtn" class="ghost" disabled>Print</button>
            </div>

            <div class="row">
              <span class="pill">Template</span>
              <select id="template">
                <option value="strip">Photo Strip (3 frames)</option>
                <option value="postcard3">Postcard Collage</option>
                <option value="film3">Film Border</option>
              </select>
              <span class="pill">Caption</span>
              <input id="caption" placeholder="e.g., Yash & Friends" />
            </div>

            <div id="countdown" class="countdown">3</div>
          </div>
        </div>

        <div class="side">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
            <div>
              <div class="panelTitle">Your 3 shots</div>
              <p class="sub" style="margin:0;">Camera or Upload. Save-to-Timeline needs unlock.</p>
            </div>
            <div class="modeTag" id="modeTag">
              <span id="modeDot" class="modeDot camera"></span>
              <span id="modeText">Camera</span>
            </div>
          </div>

          <div id="thumbs" class="miniGrid"></div>

          <div class="row">
            <span class="pill">Vintage</span>
            <input id="strength" type="range" min="0" max="100" value="65" style="flex:1" />
          </div>
          <div class="row">
            <span class="pill">Grain</span>
            <input id="grain" type="range" min="0" max="100" value="35" style="flex:1" />
          </div>
          <div class="row">
            <span class="pill">Date stamp</span>
            <select id="datestamp">
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>

          <button id="makeBtn" class="primary" disabled>Generate Template</button>

          <div class="metaGrid">
            <div>
              <div class="smallLabel">People (comma-separated)</div>
              <input id="peopleInput" placeholder="e.g., Aditi, Rohan, Mom" />
              <div class="smallLabel" style="margin-top:8px;">Quick pick (your vault)</div>
              <div id="peopleSuggestions" class="chipRow"></div>
            </div>

            <div>
              <div class="smallLabel">Place label</div>
              <input id="placeLabel" placeholder="e.g., DLF Mall / Wedding Venue" />
            </div>

            <div>
              <div class="smallLabel">Memory date & time</div>
              <input id="memoryDate" type="datetime-local" />
              <div class="hint" id="memoryDateHint" style="margin-top:6px;">Camera memories auto-set this to now. Upload lets you backfill old trips.</div>
            </div>

            <div class="row">
              <button id="geoBtn" class="mutedBtn">Get GPS</button>
              <button id="pickOnMapBtn" class="mutedBtn">Pick on Map</button>
              <span id="geoStatus" class="pill">GPS: not captured</span>
            </div>

            <button id="saveBtn" class="primary" disabled>Save to Timeline (Locked)</button>
          </div>

          <p class="sub" id="saveHint">Generate output first. Then unlock to save.</p>
        </div>
      </div>

      <div class="footerNote">
        <span>Local-only vaults. Encrypted on this device.</span>
        <span>Upload flow lets you add past memories.</span>
      </div>
    </div>

    <div id="timelineView" class="card" style="display:none;">
      <div class="timelineWrap">
        <div class="timelineHeader">
          <div>
            <div class="timelineTitle">Memories Timeline</div>
            <div class="hint">List / Pins / Heat. Only your unlocked vault.</div>
          </div>
          <div class="filters">
            <button id="viewListBtn" class="mutedBtn">List</button>
            <button id="viewPinsBtn" class="mutedBtn">Pins</button>
            <button id="viewHeatBtn" class="mutedBtn">Heat</button>

            <select id="personFilter">
              <option value="">All people</option>
            </select>
            <input id="searchFilter" placeholder="Search place / caption" />

            <!-- NEW: import a shared memory into CURRENT unlocked profile -->
            <button id="importMemoryBtn" class="mutedBtn">Import Memory</button>

            <!-- NEW: multi-select export -->
            <button id="selectModeBtn" class="mutedBtn">Select</button>
            <button id="selectAllBtn" class="mutedBtn" disabled>Select All</button>
            <button id="clearSelectionBtn" class="mutedBtn" disabled>Clear</button>
            <button id="exportSelectedBtn" class="mutedBtn" disabled>Export Selected</button>

            <button id="exportMyVaultBtn" class="mutedBtn">Export Vault</button>
            <button id="refreshTimeline" class="mutedBtn">Refresh</button>
            <button id="clearAll" class="dangerBtn">Clear My Vault</button>
          </div>
        </div>

        <div class="timelineRail">
          <div id="timelineGrid" class="timelineGrid"></div>

          <div id="mapWrap" style="display:none; padding:16px 6px 8px;">
            <div id="map" style="height:520px; border-radius:16px; border:1px solid rgba(0,0,0,.08); overflow:hidden;"></div>
            <div class="hint" style="margin-top:10px;">Pins/Heat show GPS memories only.</div>
          </div>
        </div>
      </div>
      <div class="footerNote">
        <span>Encrypted + local.</span>
        <span id="stats">—</span>
      </div>
    </div>
  </div>

  <!-- Full image modal -->
  <div id="modal" class="modal">
    <div class="modalCard">
      <div class="modalHead">
        <div class="title" id="modalTitle">Memory</div>
        <button id="modalClose" class="mutedBtn">Close</button>
      </div>
      <div class="modalBody">
        <img id="modalImg" alt="memory" />
      </div>
    </div>
  </div>

  <!-- Geo picker modal -->
  <div id="geoModal" class="geoModal">
    <div class="geoCard">
      <div class="geoHead">
        <div class="title">Pick a location</div>
        <div class="row">
          <button id="geoPickClear" class="mutedBtn">Clear</button>
          <button id="geoPickSave" class="primary">Save</button>
          <button id="geoPickClose" class="mutedBtn">Close</button>
        </div>
      </div>
      <div class="geoBody">
        <div id="geoPickMap"></div>
        <div class="hint" style="margin-top:10px;">Click on map to drop a pin. Save to attach it to this memory.</div>
      </div>
    </div>
  </div>

  <!-- Profile Gate -->
  <div id="gate" class="gate">
    <div class="gateCard">
      <div class="gateHead">
        <div>
          <div class="gateTitle">Choose a profile</div>
          <div class="hint">Each profile is a private vault protected by PIN.</div>
        </div>
        <button id="gateClose" class="mutedBtn">Continue as Guest</button>
      </div>

      <div class="gateBody">
        <div class="box">
          <div class="panelTitle">Existing profiles</div>
          <div class="hint" style="margin-top:-6px;">Tap a profile → enter PIN → unlock timeline.</div>
          <div style="height:10px"></div>
          <div id="profilesGrid" class="profilesGrid"></div>
          <div id="noProfiles" class="hint" style="display:none; margin-top:10px;">No profiles yet. Create or import one.</div>
        </div>

        <div class="box">
          <div class="panelTitle">Create new profile</div>
          <div class="hint" style="margin-top:-6px;">Use a PIN you will remember. No recovery.</div>
          <div style="height:10px"></div>

          <div class="smallLabel">Profile name</div>
          <input id="newName" placeholder="e.g., Yash" />

          <div style="height:10px"></div>
          <div class="smallLabel">PIN (4–12 digits)</div>
          <input id="newPin" type="password" inputmode="numeric" placeholder="••••" />

          <div style="height:10px"></div>
          <div class="row">
            <button id="createProfileBtn" class="primary">Create</button>
            <span id="createMsg" class="hint"></span>
          </div>

          <div style="height:14px"></div>
          <div class="panelTitle" style="margin-top:8px;">Import vault</div>
          <div class="hint" style="margin-top:-6px;">Import your exported file (.vpb.json). Creates a new profile on this device.</div>
          <div style="height:10px"></div>
          <div class="row">
            <button id="importVaultBtn" class="mutedBtn">Import</button>
            <span id="importMsg" class="hint"></span>
          </div>

          <div style="height:14px"></div>
          <div class="hint">
            Guest mode: you can still take photos + download/print, but you can’t save or view timeline.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file inputs -->
  <input id="importFile" type="file" accept=".json,application/json" style="display:none" />
  <input id="uploadFiles" type="file" accept="image/*" multiple style="display:none" />

  <!-- NEW: import a single shared memory into current profile -->
  <input id="importMemoryFile" type="file" accept=".json,application/json" style="display:none" />

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <!-- Heatmap plugin -->
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

<script>
/* =========================================================
   DB (IndexedDB)
========================================================= */
const DB_NAME = "vintage_photobooth_db";
const DB_VER  = 3; // bumped for forward-compat; schema unchanged
const STORE_EVENTS   = "events";   // encrypted memories
const STORE_PROFILES = "profiles"; // profile metadata

function openDB(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = () => {
      const db = req.result;

      if (!db.objectStoreNames.contains(STORE_PROFILES)) {
        const p = db.createObjectStore(STORE_PROFILES, { keyPath: "id" });
        p.createIndex("createdAt", "createdAt", { unique:false });
        p.createIndex("name", "name", { unique:false });
      }

      if (!db.objectStoreNames.contains(STORE_EVENTS)) {
        const e = db.createObjectStore(STORE_EVENTS, { keyPath: "id" });
        e.createIndex("profileId", "profileId", { unique:false });
        e.createIndex("createdAt", "createdAt", { unique:false });
      } else {
        const store = req.transaction.objectStore(STORE_EVENTS);
        if (!store.indexNames.contains("profileId")) store.createIndex("profileId", "profileId", { unique:false });
        if (!store.indexNames.contains("createdAt")) store.createIndex("createdAt", "createdAt", { unique:false });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function dbPut(storeName, obj){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).put(obj);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}
async function dbGet(storeName, id){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).get(id);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(tx.error);
  });
}
async function dbGetAll(storeName){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
async function dbDelete(storeName, id){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).delete(id);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}
async function dbClearWhereProfile(profileId){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_EVENTS, "readwrite");
    const store = tx.objectStore(STORE_EVENTS);
    const idx = store.index("profileId");
    const range = IDBKeyRange.only(profileId);
    const req = idx.openCursor(range);
    req.onsuccess = () => {
      const cursor = req.result;
      if (cursor) {
        cursor.delete();
        cursor.continue();
      }
    };
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

/* =========================================================
   Helpers
========================================================= */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function nowISO(){ return new Date().toISOString(); }
function fmtDateTime(iso){
  const d = new Date(iso);
  return d.toLocaleString(undefined, { weekday:"short", year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
}
function sanitizePeopleInput(s){
  return (s || "").split(",").map(x => x.trim()).filter(Boolean).slice(0, 10);
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function canvasToDataURL(canvas, quality=0.92){
  return canvas.toDataURL("image/jpeg", quality);
}
function escapeHtml(s){
  return (s||"").replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]));
}
function ab2b64(buf){
  const bytes = new Uint8Array(buf);
  let bin = "";
  for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}
function b642ab(b64){
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  return bytes.buffer;
}
function randBytes(n){
  const a = new Uint8Array(n);
  crypto.getRandomValues(a);
  return a;
}
async function sha256(ab){
  return crypto.subtle.digest("SHA-256", ab);
}
async function importRawKeyFromPin(pin){
  return crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(pin),
    { name:"PBKDF2" },
    false,
    ["deriveKey","deriveBits"]
  );
}
async function deriveAesKey(pin, saltB64, iterations=150000){
  const salt = new Uint8Array(b642ab(saltB64));
  const baseKey = await importRawKeyFromPin(pin);
  return crypto.subtle.deriveKey(
    { name:"PBKDF2", salt, iterations, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}
async function deriveBits(pin, saltB64, iterations=150000){
  const salt = new Uint8Array(b642ab(saltB64));
  const baseKey = await importRawKeyFromPin(pin);
  const bits = await crypto.subtle.deriveBits(
    { name:"PBKDF2", salt, iterations, hash:"SHA-256" },
    baseKey,
    256
  );
  return bits;
}
async function encryptJSON(aesKey, obj){
  const iv = randBytes(12);
  const pt = new TextEncoder().encode(JSON.stringify(obj));
  const ct = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, pt);
  return { ivB64: ab2b64(iv.buffer), ctB64: ab2b64(ct) };
}
async function decryptJSON(aesKey, ivB64, ctB64){
  const iv = new Uint8Array(b642ab(ivB64));
  const ct = b642ab(ctB64);
  const pt = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, ct);
  const txt = new TextDecoder().decode(pt);
  return JSON.parse(txt);
}
function b64ApproxBytes(b64){
  if (!b64) return 0;
  const pad = (b64.endsWith("==") ? 2 : b64.endsWith("=") ? 1 : 0);
  return Math.max(0, Math.floor((b64.length * 3)/4) - pad);
}
function fmtBytes(bytes){
  const u = ["B","KB","MB","GB"];
  let v = bytes;
  let i = 0;
  while (v >= 1024 && i < u.length-1){ v /= 1024; i++; }
  return `${v.toFixed(i===0?0:1)} ${u[i]}`;
}
function safeFileName(s){
  return (s||"vault").replace(/[^a-z0-9_\-]+/gi, "_").slice(0,60);
}
function toLocalDatetimeValue(date){
  const d = new Date(date);
  const pad = (n)=>String(n).padStart(2,"0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth()+1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const mi = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
}
function getMemoryISOFromInput(){
  const v = (memoryDate.value || "").trim();
  if (!v) return nowISO();
  const d = new Date(v);
  if (isNaN(d.getTime())) return nowISO();
  return d.toISOString();
}

/* =========================================================
   UI refs
========================================================= */
const tabBooth = document.getElementById("tabBooth");
const tabTimeline = document.getElementById("tabTimeline");
const boothView = document.getElementById("boothView");
const timelineView = document.getElementById("timelineView");

const statusDot = document.getElementById("statusDot");
const sessionText = document.getElementById("sessionText");
const switchProfileBtn = document.getElementById("switchProfileBtn");
const lockBtn = document.getElementById("lockBtn");

const video = document.getElementById('video');
const out = document.getElementById('out');
const ctxOut = out.getContext('2d');

const startBtn = document.getElementById('startBtn');
const flipBtn = document.getElementById('flipBtn');
const shootBtn = document.getElementById('shootBtn');
const uploadBtn = document.getElementById('uploadBtn');
const retakeBtn = document.getElementById('retakeBtn');
const makeBtn = document.getElementById('makeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const printBtn = document.getElementById('printBtn');
const saveBtn = document.getElementById('saveBtn');

const thumbs = document.getElementById('thumbs');
const countdownEl = document.getElementById('countdown');

const templateSel = document.getElementById('template');
const captionInp = document.getElementById('caption');
const strengthInp = document.getElementById('strength');
const grainInp = document.getElementById('grain');
const datestampSel = document.getElementById('datestamp');

const peopleInput = document.getElementById("peopleInput");
const peopleSuggestions = document.getElementById("peopleSuggestions");
const placeLabel = document.getElementById("placeLabel");
const memoryDate = document.getElementById("memoryDate");
const memoryDateHint = document.getElementById("memoryDateHint");

const modeTag = document.getElementById("modeTag");
const modeDot = document.getElementById("modeDot");
const modeText = document.getElementById("modeText");

const geoBtn = document.getElementById("geoBtn");
const pickOnMapBtn = document.getElementById("pickOnMapBtn");
const geoStatus = document.getElementById("geoStatus");
let geoData = null;

const saveHint = document.getElementById("saveHint");

/* Timeline refs */
const viewListBtn = document.getElementById("viewListBtn");
const viewPinsBtn = document.getElementById("viewPinsBtn");
const viewHeatBtn = document.getElementById("viewHeatBtn");
const mapWrap = document.getElementById("mapWrap");
const mapEl = document.getElementById("map");

const personFilter = document.getElementById("personFilter");
const searchFilter = document.getElementById("searchFilter");
const exportMyVaultBtn = document.getElementById("exportMyVaultBtn");
const refreshTimeline = document.getElementById("refreshTimeline");
const clearAll = document.getElementById("clearAll");
const timelineGrid = document.getElementById("timelineGrid");
const stats = document.getElementById("stats");

/* NEW: Import memory button + input */
const importMemoryBtn = document.getElementById("importMemoryBtn");
const importMemoryFile = document.getElementById("importMemoryFile");

/* NEW: Multi-select export refs */
const selectModeBtn = document.getElementById("selectModeBtn");
const selectAllBtn = document.getElementById("selectAllBtn");
const clearSelectionBtn = document.getElementById("clearSelectionBtn");
const exportSelectedBtn = document.getElementById("exportSelectedBtn");

/* Modal */
const modal = document.getElementById("modal");
const modalTitle = document.getElementById("modalTitle");
const modalImg = document.getElementById("modalImg");
const modalClose = document.getElementById("modalClose");

/* Gate */
const gate = document.getElementById("gate");
const gateClose = document.getElementById("gateClose");
const profilesGrid = document.getElementById("profilesGrid");
const noProfiles = document.getElementById("noProfiles");
const newName = document.getElementById("newName");
const newPin = document.getElementById("newPin");
const createProfileBtn = document.getElementById("createProfileBtn");
const createMsg = document.getElementById("createMsg");

const importVaultBtn = document.getElementById("importVaultBtn");
const importMsg = document.getElementById("importMsg");
const importFile = document.getElementById("importFile");

/* Upload input */
const uploadFiles = document.getElementById("uploadFiles");

/* Geo picker modal refs */
const geoModal = document.getElementById("geoModal");
const geoPickClose = document.getElementById("geoPickClose");
const geoPickSave = document.getElementById("geoPickSave");
const geoPickClear = document.getElementById("geoPickClear");

/* =========================================================
   Session state (in-memory only)
========================================================= */
let activeProfileId = null;
let activeProfileName = null;
let sessionKey = null;

function isUnlocked(){
  return !!(activeProfileId && sessionKey);
}

let captureMode = "camera"; // "camera" | "upload"
function setMode(mode){
  captureMode = mode;
  if (mode === "camera"){
    modeDot.className = "modeDot camera";
    modeText.textContent = "Camera";
    memoryDate.value = toLocalDatetimeValue(new Date());
    memoryDate.disabled = true;
    memoryDateHint.textContent = "Camera memories auto-set this to now. Upload lets you backfill old trips.";
  } else {
    modeDot.className = "modeDot upload";
    modeText.textContent = "Upload";
    memoryDate.disabled = false;
    if (!memoryDate.value) memoryDate.value = toLocalDatetimeValue(new Date());
    memoryDateHint.textContent = "Upload mode: set the real date/time from the past trip.";
  }
}

function setSessionUI(){
  if (isUnlocked()){
    statusDot.classList.remove("red"); statusDot.classList.add("green");
    sessionText.textContent = `${activeProfileName} (unlocked)`;
    lockBtn.style.display = "";
    tabTimeline.disabled = false;

    uploadBtn.disabled = false;
    pickOnMapBtn.disabled = false;

    saveBtn.disabled = (out.style.display === "none") ? true : false;
    saveBtn.textContent = "Save to Timeline";
    saveHint.textContent = (out.style.display === "none") ? "Generate output first. Then save." : "Ready. Save this memory to your timeline.";
  } else {
    statusDot.classList.remove("green"); statusDot.classList.add("red");
    sessionText.textContent = "Guest (locked)";
    lockBtn.style.display = "none";
    tabTimeline.disabled = true;

    uploadBtn.disabled = true;
    pickOnMapBtn.disabled = true;

    saveBtn.disabled = true;
    saveBtn.textContent = "Save to Timeline (Locked)";
    saveHint.textContent = "Generate output first. Then unlock to save.";
  }
  setSelectionButtonsUI();
}

/* =========================================================
   Map (timeline) + heat
========================================================= */
let mapInstance = null;
let clusterLayer = null;
let heatLayer = null;
let mapBuilt = false;

function clearMapLayers(){
  if (!mapInstance) return;
  try{
    if (clusterLayer && mapInstance.hasLayer(clusterLayer)) mapInstance.removeLayer(clusterLayer);
  }catch(_){}
  try{
    if (heatLayer && mapInstance.hasLayer(heatLayer)) mapInstance.removeLayer(heatLayer);
  }catch(_){}
  try{ if (clusterLayer) clusterLayer.clearLayers(); }catch(_){}
  heatLayer = null;
}
function ensureMap(){
  if (mapBuilt) return;
  mapBuilt = true;

  mapInstance = L.map(mapEl, { zoomControl:true }).setView([20.5937, 78.9629], 5);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap"
  }).addTo(mapInstance);

  clusterLayer = L.markerClusterGroup({
    showCoverageOnHover: false,
    spiderfyOnMaxZoom: true,
    disableClusteringAtZoom: 17
  });
}
function fitToBounds(points){
  if (!mapInstance || points.length === 0) {
    if (mapInstance) mapInstance.setView([20.5937, 78.9629], 5);
    return;
  }
  const b = L.latLngBounds(points);
  mapInstance.fitBounds(b, { padding:[30,30] });
}

/* =========================================================
   HARD wipe visuals (prevents old photo flashing)
========================================================= */
function wipeAllVisuals(){
  try{ modal.style.display = "none"; }catch(_){}
  try{ modalImg.src = ""; }catch(_){}

  try{ thumbs.innerHTML = ""; }catch(_){}

  try{
    ctxOut.setTransform(1,0,0,1,0,0);
    ctxOut.clearRect(0,0,out.width,out.height);
    ctxOut.fillStyle = "#000";
    ctxOut.fillRect(0,0,out.width,out.height);
  }catch(_){}

  out.style.display = "none";
  video.style.display = "block";

  try{ timelineGrid.innerHTML = ""; }catch(_){}
  try{ mapWrap.style.display = "none"; }catch(_){}
  try{ clearMapLayers(); }catch(_){}

  captionInp.value = "";
  peopleInput.value = "";
  placeLabel.value = "";
  geoData = null;
  geoStatus.textContent = "GPS: not captured";

  shots = [];
  makeBtn.disabled = true;
  downloadBtn.disabled = true;
  printBtn.disabled = true;
  saveBtn.disabled = true;

  setMode("camera");
}

/* =========================================================
   Camera
========================================================= */
let stream = null;
let facingMode = "user";
let shots = [];

function stopCamera(){
  try{ if (stream) stream.getTracks().forEach(t => t.stop()); }catch(_){}
  stream = null;
  try{ video.srcObject = null; }catch(_){}
  startBtn.disabled = false;
  startBtn.textContent = "Start Camera";
  flipBtn.disabled = true;
  shootBtn.disabled = true;
  retakeBtn.disabled = true;
}
async function startCamera(){
  if (stream) stream.getTracks().forEach(t => t.stop());
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  flipBtn.disabled = false;
  shootBtn.disabled = false;
  retakeBtn.disabled = false;
  startBtn.textContent = "Camera On";
  startBtn.disabled = true;

  setMode("camera");
}
function captureFrame(){
  const c = document.createElement('canvas');
  const w = video.videoWidth, h = video.videoHeight;
  c.width = w; c.height = h;
  const cctx = c.getContext('2d');
  if (facingMode === "user"){
    cctx.translate(w, 0);
    cctx.scale(-1, 1);
  }
  cctx.drawImage(video, 0, 0, w, h);
  return c.toDataURL('image/jpeg', 0.92);
}
function renderThumbs(){
  thumbs.innerHTML = "";
  shots.forEach((src) => {
    const div = document.createElement('div');
    div.className = "thumb";
    const img = document.createElement('img');
    img.src = src;
    div.appendChild(img);
    thumbs.appendChild(div);
  });
}
async function countdown(n=3){
  countdownEl.style.display = "block";
  for (let i=n; i>=1; i--){
    countdownEl.textContent = i;
    await sleep(650);
  }
  countdownEl.textContent = "✦";
  await sleep(220);
  countdownEl.style.display = "none";
}
async function takeBurst(){
  wipeAllVisuals();
  setMode("camera");
  shots = [];
  renderThumbs();
  makeBtn.disabled = true;

  for (let i=0; i<3; i++){
    await countdown(3);
    shots.push(captureFrame());
    renderThumbs();
    await sleep(350);
  }
  makeBtn.disabled = false;
}

/* =========================================================
   Upload 3 photos (locked-only)
========================================================= */
async function readFileAsDataURL(file){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(String(fr.result || ""));
    fr.onerror = () => reject(fr.error);
    fr.readAsDataURL(file);
  });
}
async function pickUpload3(){
  if (!isUnlocked()) return;
  uploadFiles.value = "";
  uploadFiles.click();
}
async function handleUploadFiles(files){
  if (!isUnlocked()) return;
  const arr = Array.from(files || []);
  if (arr.length !== 3){
    alert("Select exactly 3 photos.");
    return;
  }
  wipeAllVisuals();
  stopCamera();
  setMode("upload");

  shots = [];
  for (const f of arr){
    const url = await readFileAsDataURL(f);
    shots.push(url);
  }
  renderThumbs();
  makeBtn.disabled = false;
}

/* =========================================================
   GPS
========================================================= */
async function getGeo(){
  return new Promise((resolve) => {
    if (!navigator.geolocation) return resolve(null);
    navigator.geolocation.getCurrentPosition(
      (pos) => resolve({
        lat: +pos.coords.latitude.toFixed(6),
        lng: +pos.coords.longitude.toFixed(6),
        accuracy_m: Math.round(pos.coords.accuracy || 0),
      }),
      () => resolve(null),
      { enableHighAccuracy: true, timeout: 9000, maximumAge: 60000 }
    );
  });
}

/* =========================================================
   Geo Picker (manual pin)
========================================================= */
let geoPickMap = null;
let geoPickMarker = null;
let geoPickLatLng = null;

function openGeoPicker(){
  if (!isUnlocked()) return;

  geoModal.style.display = "flex";

  if (!geoPickMap){
    geoPickMap = L.map("geoPickMap", { zoomControl:true }).setView([20.5937, 78.9629], 5);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap"
    }).addTo(geoPickMap);

    geoPickMap.on("click", (e) => {
      geoPickLatLng = e.latlng;
      if (!geoPickMarker){
        geoPickMarker = L.marker(geoPickLatLng).addTo(geoPickMap);
      } else {
        geoPickMarker.setLatLng(geoPickLatLng);
      }
    });
  }

  setTimeout(() => geoPickMap.invalidateSize(), 60);

  if (geoData && typeof geoData.lat === "number" && typeof geoData.lng === "number"){
    geoPickLatLng = L.latLng(geoData.lat, geoData.lng);
    if (!geoPickMarker){
      geoPickMarker = L.marker(geoPickLatLng).addTo(geoPickMap);
    } else {
      geoPickMarker.setLatLng(geoPickLatLng);
    }
    geoPickMap.setView(geoPickLatLng, 13);
  }
}
function closeGeoPicker(){
  geoModal.style.display = "none";
}
function clearGeoPick(){
  geoPickLatLng = null;
  if (geoPickMarker){
    try{ geoPickMap.removeLayer(geoPickMarker); }catch(_){}
    geoPickMarker = null;
  }
}
function saveGeoPick(){
  if (!geoPickLatLng){
    geoData = null;
    geoStatus.textContent = "GPS: not captured";
    closeGeoPicker();
    return;
  }
  geoData = {
    lat: +geoPickLatLng.lat.toFixed(6),
    lng: +geoPickLatLng.lng.toFixed(6),
    accuracy_m: 0
  };
  geoStatus.textContent = `GPS: ${geoData.lat}, ${geoData.lng} (manual pin)`;
  closeGeoPicker();
}

/* =========================================================
   Drawing + Templates
========================================================= */
function addGrain(imageData, amount){
  const d = imageData.data;
  const a = amount / 100;
  const noise = 28 * a;
  for (let i=0; i<d.length; i+=4){
    const n = (Math.random() - 0.5) * noise;
    d[i]   = Math.min(255, Math.max(0, d[i]   + n));
    d[i+1] = Math.min(255, Math.max(0, d[i+1] + n));
    d[i+2] = Math.min(255, Math.max(0, d[i+2] + n));
  }
  return imageData;
}
function vintageGrade(imageData, strength){
  const d = imageData.data;
  const s = strength / 100;
  for (let i=0; i<d.length; i+=4){
    let r = d[i], g = d[i+1], b = d[i+2];
    r = r + (18 * s);
    g = g + (12 * s);
    b = b + (7  * s);
    r = r + (24 * s);
    b = b - (14 * s);
    const mid = 128;
    r = mid + (r - mid) * (1 - 0.18*s);
    g = mid + (g - mid) * (1 - 0.18*s);
    b = mid + (b - mid) * (1 - 0.18*s);
    const gray = 0.299*r + 0.587*g + 0.114*b;
    r = r*(1-0.22*s) + gray*(0.22*s);
    g = g*(1-0.22*s) + gray*(0.22*s);
    b = b*(1-0.22*s) + gray*(0.22*s);
    d[i]   = Math.min(255, Math.max(0, r));
    d[i+1] = Math.min(255, Math.max(0, g));
    d[i+2] = Math.min(255, Math.max(0, b));
  }
  return imageData;
}
function drawRoundedRect(ctx, x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}
function drawCover(ctx, img, x,y,w,h, radius=0){
  const iw = img.width, ih = img.height;
  const tr = w/h, ir = iw/ih;
  let sx=0, sy=0, sw=iw, sh=ih;
  if (ir > tr){ sw = ih*tr; sx=(iw-sw)/2; }
  else { sh = iw/tr; sy=(ih-sh)/2; }

  ctx.save();
  if (radius>0){
    drawRoundedRect(ctx, x,y,w,h,radius);
    ctx.clip();
  } else {
    ctx.beginPath();
    ctx.rect(x,y,w,h);
    ctx.clip();
  }
  ctx.drawImage(img, sx, sy, sw, sh, x,y,w,h);
  const data = ctx.getImageData(x,y,w,h);
  ctx.putImageData(addGrain(vintageGrade(data, +strengthInp.value), +grainInp.value), x,y);
  ctx.restore();
}
function drawDateStamp(ctx, x, y, iso){
  const d = iso ? new Date(iso) : new Date();
  const stamp = d.toLocaleDateString(undefined, { year:"numeric", month:"2-digit", day:"2-digit" });
  ctx.save();
  ctx.textAlign="right";
  ctx.fillStyle="rgba(0,0,0,.55)";
  ctx.font="800 30px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText(stamp, x, y);
  ctx.restore();
}
async function toImages(dataUrls){
  const imgs = [];
  for (const s of dataUrls){
    const im = new Image();
    im.src = s;
    await im.decode();
    imgs.push(im);
  }
  return imgs;
}

function templateStrip(imgs, caption, withDate, iso){
  out.width = 1200; out.height = 2400;
  const W = out.width, H = out.height;
  ctxOut.clearRect(0,0,W,H);
  ctxOut.fillStyle = "#fbf6eb";
  ctxOut.fillRect(0,0,W,H);

  const pad = 160;
  const frameW = W - pad*2;
  const frameH = 520;
  const gap = 60;
  const top = 170;

  ctxOut.fillStyle="#ffffff";
  ctxOut.fillRect(pad-24, top-24, frameW+48, (frameH*3 + gap*2)+48);

  for(let i=0;i<3;i++){
    drawCover(ctxOut, imgs[i], pad, top + i*(frameH+gap), frameW, frameH, 18);
    ctxOut.strokeStyle="rgba(0,0,0,.08)";
    ctxOut.lineWidth=3;
    ctxOut.strokeRect(pad, top + i*(frameH+gap), frameW, frameH);
  }

  ctxOut.fillStyle="#1a1a1a";
  ctxOut.font="900 54px ui-serif, Georgia, 'Times New Roman', serif";
  ctxOut.textAlign="left";
  ctxOut.fillText(caption || "—", pad-10, top + frameH*3 + gap*2 + 160);

  ctxOut.fillStyle="rgba(26,26,26,.62)";
  ctxOut.font="400 30px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctxOut.fillText("photo strip", pad-10, top + frameH*3 + gap*2 + 210);

  if (withDate) drawDateStamp(ctxOut, W - pad + 10, H - 140, iso);
}

function templatePostcard3(imgs, caption, withDate, iso){
  out.width = 1600; out.height = 1100;
  const W = out.width, H = out.height;
  ctxOut.clearRect(0,0,W,H);
  ctxOut.fillStyle="#fbf6eb";
  ctxOut.fillRect(0,0,W,H);

  const pad = 70;
  const leftW = Math.floor(W*0.58);
  const collageX = pad, collageY = pad, collageW = leftW - pad*1.2, collageH = H - pad*2;
  ctxOut.fillStyle="#ffffff";
  ctxOut.fillRect(collageX-18, collageY-18, collageW+36, collageH+36);

  const gap = 26;
  const cellH = Math.floor((collageH - gap*2)/3);
  for(let i=0;i<3;i++){
    drawCover(ctxOut, imgs[i], collageX, collageY + i*(cellH+gap), collageW, cellH, 16);
    ctxOut.strokeStyle="rgba(0,0,0,.08)";
    ctxOut.lineWidth=3;
    ctxOut.strokeRect(collageX, collageY + i*(cellH+gap), collageW, cellH);
  }

  const rightX = leftW + 20;
  ctxOut.fillStyle="rgba(26,26,26,.70)";
  ctxOut.font="900 46px ui-serif, Georgia, 'Times New Roman', serif";
  ctxOut.textAlign="left";
  ctxOut.fillText(caption || "Greetings", rightX, pad + 70);

  ctxOut.fillStyle="rgba(26,26,26,.55)";
  ctxOut.font="400 26px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctxOut.fillText("Wish you were here.", rightX, pad + 112);

  ctxOut.strokeStyle="rgba(0,0,0,.12)";
  ctxOut.lineWidth=4;
  ctxOut.beginPath();
  ctxOut.moveTo(leftW+10, pad);
  ctxOut.lineTo(leftW+10, H-pad);
  ctxOut.stroke();

  const linesX = rightX;
  const linesY = pad + 200;
  ctxOut.strokeStyle="rgba(0,0,0,.14)";
  ctxOut.lineWidth=3;
  for(let i=0;i<6;i++){
    ctxOut.beginPath();
    ctxOut.moveTo(linesX, linesY + i*90);
    ctxOut.lineTo(W - pad, linesY + i*90);
    ctxOut.stroke();
  }

  if (withDate) drawDateStamp(ctxOut, W - pad, H - 70, iso);
}

function templateFilm3(imgs, caption, withDate, iso){
  out.width = 1600; out.height = 2200;
  const W = out.width, H = out.height;
  ctxOut.clearRect(0,0,W,H);
  ctxOut.fillStyle="#0f0f0f";
  ctxOut.fillRect(0,0,W,H);

  const pad = 170;
  const filmX = pad, filmY = 160, filmW = W - pad*2, filmH = H - 320;

  ctxOut.fillStyle="#141414";
  ctxOut.fillRect(filmX, filmY, filmW, filmH);

  function sprockets(x){
    const holeW = 60, holeH = 44;
    const gap = 26;
    const top = filmY + 70;
    const count = Math.floor((filmH - 140) / (holeH + gap));
    ctxOut.fillStyle="#0b0b0b";
    for(let i=0;i<count;i++){
      const y = top + i*(holeH+gap);
      drawRoundedRect(ctxOut, x, y, holeW, holeH, 10);
      ctxOut.fill();
    }
  }
  sprockets(filmX + 32);
  sprockets(filmX + filmW - 32 - 60);

  const innerX = filmX + 120;
  const innerW = filmW - 240;
  const frameH = 470;
  const gapY = 90;
  const startY = filmY + 120;

  for(let i=0;i<3;i++){
    const x = innerX;
    const y = startY + i*(frameH+gapY);
    ctxOut.fillStyle="#000";
    ctxOut.fillRect(x-18, y-18, innerW+36, frameH+36);
    drawCover(ctxOut, imgs[i], x, y, innerW, frameH, 8);

    ctxOut.fillStyle="rgba(255,255,255,.55)";
    ctxOut.font="700 26px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctxOut.fillText("KODAK 400", filmX + 120, y - 40);
    ctxOut.textAlign="right";
    ctxOut.fillText(String(i+1).padStart(2,"0"), filmX + filmW - 120, y - 40);
    ctxOut.textAlign="left";
  }

  ctxOut.fillStyle="#fbf6eb";
  ctxOut.fillRect(0,0,W,140);
  ctxOut.fillStyle="#1a1a1a";
  ctxOut.font="900 54px ui-serif, Georgia, 'Times New Roman', serif";
  ctxOut.textAlign="left";
  ctxOut.fillText(caption || "—", 90, 92);

  if (withDate) drawDateStamp(ctxOut, W - 90, 92, iso);
}

/* =========================================================
   Generate
========================================================= */
async function generate(){
  if (shots.length !== 3) return;

  const imgs = await toImages(shots);
  const caption = captionInp.value.trim();
  const withDate = datestampSel.value === "on";
  const t = templateSel.value;
  const iso = getMemoryISOFromInput();

  if (t === "strip") templateStrip(imgs, caption, withDate, iso);
  if (t === "postcard3") templatePostcard3(imgs, caption, withDate, iso);
  if (t === "film3") templateFilm3(imgs, caption, withDate, iso);

  out.style.display = "block";
  video.style.display = "none";
  downloadBtn.disabled = false;
  printBtn.disabled = false;

  setSessionUI();
}

/* =========================================================
   Download / Print
========================================================= */
function download(){
  const link = document.createElement('a');
  link.download = "vintage_template.jpg";
  link.href = out.toDataURL("image/jpeg", 0.92);
  link.click();
}
function printCard(){
  const dataUrl = out.toDataURL("image/jpeg", 0.92);
  const w = window.open("", "_blank");
  w.document.write(`<img src="${dataUrl}" style="width:100%;max-width:900px;display:block;margin:20px auto;">`);
  w.document.write(`<script>window.onload=()=>{window.print();};<\/script>`);
  w.document.close();
}

/* =========================================================
   Save memory (encrypted)
========================================================= */
async function saveMemory(){
  if (!isUnlocked()) return;
  if (out.style.display === "none") return;

  const people = sanitizePeopleInput(peopleInput.value);
  const place = (placeLabel.value || "").trim() || null;

  const finalDataURL = canvasToDataURL(out, 0.92);

  const tCanvas = document.createElement("canvas");
  const maxW = 520;
  const ratio = out.height / out.width;
  tCanvas.width = maxW;
  tCanvas.height = Math.round(maxW * ratio);
  const tctx = tCanvas.getContext("2d");
  tctx.drawImage(out, 0, 0, tCanvas.width, tCanvas.height);
  const thumbDataURL = canvasToDataURL(tCanvas, 0.86);

  const memoryISO = getMemoryISOFromInput();

  const payload = {
    createdAt: memoryISO,
    capturedAt: nowISO(),
    source: captureMode,
    template: templateSel.value,
    caption: (captionInp.value || "").trim() || null,
    people,
    placeLabel: place,
    geo: geoData,
    finalDataURL,
    thumbDataURL
  };

  const enc = await encryptJSON(sessionKey, payload);

  const event = {
    id: crypto.randomUUID(),
    profileId: activeProfileId,
    createdAt: payload.createdAt,
    enc,
    meta: null
  };

  await dbPut(STORE_EVENTS, event);

  saveHint.textContent = "Saved to your vault.";

  wipeAllVisuals();
}

/* =========================================================
   Timeline + Map/Heat
========================================================= */
let currentView = "list";

/* =========================================================
   NEW: Multi-select export (timeline)
========================================================= */
let selectionMode = false;
let selectedIds = new Set();
let lastFilteredIds = [];

function setSelectionButtonsUI(){
  const any = selectedIds.size > 0;
  if (typeof selectAllBtn !== "undefined") selectAllBtn.disabled = !selectionMode || lastFilteredIds.length === 0;
  if (typeof clearSelectionBtn !== "undefined") clearSelectionBtn.disabled = !selectionMode || !any;
  if (typeof exportSelectedBtn !== "undefined") exportSelectedBtn.disabled = !selectionMode || !any;
  if (typeof selectModeBtn !== "undefined") selectModeBtn.textContent = selectionMode ? "Done" : "Select";
}

function toggleSelectionMode(){
  selectionMode = !selectionMode;
  if (!selectionMode) selectedIds.clear();
  setSelectionButtonsUI();
}

function selectAllFiltered(){
  if (!selectionMode) return;
  lastFilteredIds.forEach(id => selectedIds.add(id));
  setSelectionButtonsUI();
}

function clearSelection(){
  selectedIds.clear();
  setSelectionButtonsUI();
}

async function exportSelectedMemories(){
  if (!isUnlocked()) return;
  if (!selectionMode || selectedIds.size === 0) return;

  const ids = Array.from(selectedIds);
  const memories = [];

  for (const id of ids){
    const e = await dbGet(STORE_EVENTS, id);
    if (!e) continue;
    if (e.profileId !== activeProfileId) continue;
    if (!e.enc || !e.enc.ivB64 || !e.enc.ctB64) continue;

    // Decrypt on this device, then export plaintext payload so it can be re-encrypted on import.
    try{
      const payload = await decryptJSON(sessionKey, e.enc.ivB64, e.enc.ctB64);
      memories.push(payload);
    } catch(_){ /* skip */ }
  }

  if (memories.length === 0){
    alert("No valid memories selected.");
    return;
  }

  const payload = {
    format: "VPB_MEMORY_BUNDLE_EXPORT_V2",
    exportedAt: nowISO(),
    sharedByName: activeProfileName || "Unknown",
    count: memories.length,
    memories
  };

  const json = JSON.stringify(payload);
  const blob = new Blob([json], { type:"application/json" });
  const url = URL.createObjectURL(blob);

  const fileName = `${safeFileName(activeProfileName)}_memories_${new Date().toISOString().slice(0,10)}.vpb.memories.json`;
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  a.click();

  setTimeout(() => URL.revokeObjectURL(url), 2000);

  selectedIds.clear();
  setSelectionButtonsUI();
  await refreshTimelineUI();
}

function templateLabel(t){
  if (t === "strip") return "Photo Strip";
  if (t === "postcard3") return "Postcard Collage";
  if (t === "film3") return "Film Border";
  return t || "Template";
}

async function getMyEventsEncrypted(){
  const all = await dbGetAll(STORE_EVENTS);
  return all.filter(e => e.profileId === activeProfileId);
}
async function decryptMany(encEvents){
  const outArr = [];
  let failed = 0;

  for (const e of encEvents){
    try{
      const payload = await decryptJSON(sessionKey, e.enc.ivB64, e.enc.ctB64);
      outArr.push({ id:e.id, createdAt:e.createdAt, payload, meta: e.meta || null });
    } catch(_){
      failed++;
    }
  }

  if (failed > 0){
    // shows in footer stats area
    stats.textContent = `${encEvents.length} memories • ${failed} failed to decrypt`;
  }

  return outArr;
}


function setViewButtonUI(){
  const setDim = (btn, on) => btn.style.opacity = on ? "1" : ".7";
  setDim(viewListBtn, currentView === "list");
  setDim(viewPinsBtn, currentView === "pins");
  setDim(viewHeatBtn, currentView === "heat");
}
function showListView(){
  timelineGrid.style.display = "";
  mapWrap.style.display = "none";
  setViewButtonUI();
}
function showMapWrap(){
  timelineGrid.style.display = "none";
  mapWrap.style.display = "";
  setTimeout(() => { if (mapInstance) mapInstance.invalidateSize(); }, 60);
}
function jumpToMemoryInList(targetId){
  currentView = "list";
  showListView();
  const el = document.querySelector(`[data-card-id="${targetId}"]`);
  if (el){
    el.scrollIntoView({ behavior:"smooth", block:"center" });
    el.style.outline = "3px solid rgba(106,75,47,.35)";
    setTimeout(() => { el.style.outline = ""; }, 1200);
  }
}
function buildPins(decryptedItems){
  ensureMap();
  clearMapLayers();

  const gps = decryptedItems.filter(x => x.payload.geo && typeof x.payload.geo.lat === "number" && typeof x.payload.geo.lng === "number");
  if (gps.length === 0){ mapInstance.setView([20.5937, 78.9629], 5); return; }

  const bounds = [];
  gps.forEach(x => {
    const p = x.payload;
    bounds.push([p.geo.lat, p.geo.lng]);

    const when = fmtDateTime(p.createdAt);
    const people = (p.people || []).slice(0,3).join(", ");
    const place = p.placeLabel ? p.placeLabel : "—";

    const popupHtml = `
      <div style="display:grid; gap:8px; width:220px;">
        <img src="${p.thumbDataURL}" style="width:100%; border-radius:10px; display:block;" />
        <div style="font-weight:800; font-size:12px;">${escapeHtml(when)}</div>
        <div style="color:rgba(0,0,0,.65); font-size:12px; line-height:1.25;">
          ${escapeHtml(place)}<br/>
          <span style="color:rgba(0,0,0,.55);">${escapeHtml(people || "No tags")}</span>
        </div>
        <button data-jump="${x.id}" style="padding:10px 12px;border-radius:12px;border:1px solid rgba(0,0,0,.12);background:#fff;cursor:pointer;">
          Open memory
        </button>
      </div>
    `;

    const marker = L.marker([p.geo.lat, p.geo.lng]).bindPopup(popupHtml);
    marker.on("popupopen", () => {
      const btn = document.querySelector(`button[data-jump="${x.id}"]`);
      if (btn) btn.onclick = () => jumpToMemoryInList(x.id);
    });

    clusterLayer.addLayer(marker);
  });

  clusterLayer.addTo(mapInstance);
  fitToBounds(bounds);
}
function buildHeat(decryptedItems){
  ensureMap();
  clearMapLayers();

  const gps = decryptedItems.filter(x => x.payload.geo && typeof x.payload.geo.lat === "number" && typeof x.payload.geo.lng === "number");
  if (gps.length === 0){ mapInstance.setView([20.5937, 78.9629], 5); return; }

  const pts = [];
  const bounds = [];
  gps.forEach(x => {
    const g = x.payload.geo;
    let w = 0.65;
    if (g.accuracy_m && Number.isFinite(g.accuracy_m)){
      const a = clamp(g.accuracy_m, 5, 200);
      w = 1.0 - ((a - 5) / (200 - 5)) * 0.65;
      w = clamp(w, 0.35, 1.0);
    }
    pts.push([g.lat, g.lng, w]);
    bounds.push([g.lat, g.lng]);
  });

  heatLayer = L.heatLayer(pts, { radius: 28, blur: 22, maxZoom: 17 }).addTo(mapInstance);
  fitToBounds(bounds);
}

async function refreshTimelineUI(){
  if (!isUnlocked()) return;

  const encEvents = await getMyEventsEncrypted();
  encEvents.sort((a,b) => (b.createdAt||"").localeCompare(a.createdAt||""));

  let approxBytes = 0;
  for (const e of encEvents){
    approxBytes += b64ApproxBytes(e.enc?.ivB64 || "");
    approxBytes += b64ApproxBytes(e.enc?.ctB64 || "");
  }
  stats.textContent = `${encEvents.length} memories • ~${fmtBytes(approxBytes)} encrypted`;

  const dec = await decryptMany(encEvents);

  const allPeople = [];
  dec.forEach(x => (x.payload.people || []).forEach(p => allPeople.push(p)));
  const uniquePeople = Array.from(new Set(allPeople.map(x=>x.trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
  const currentPerson = personFilter.value || "";
  personFilter.innerHTML = `<option value="">All people</option>` + uniquePeople.map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join("");
  personFilter.value = currentPerson;

  const pSel = personFilter.value || "";
  const q = (searchFilter.value || "").trim().toLowerCase();
  const filtered = dec.filter(x => {
    const p = x.payload;
    const byPerson = !pSel || (p.people || []).includes(pSel);
    const text = `${p.caption||""} ${p.placeLabel||""} ${(p.people||[]).join(" ")}`.toLowerCase();
    const bySearch = !q || text.includes(q);
    return byPerson && bySearch;
  });

  // NEW: track filtered IDs for Select All
  lastFilteredIds = filtered.map(x => x.id);
  setSelectionButtonsUI();

  timelineGrid.innerHTML = "";

  if (filtered.length === 0){
    timelineGrid.innerHTML = `
      <div class="tCard" style="max-width:720px;">
        <div class="tBody">
          <div class="tWhen">No memories found</div>
          <div class="tWhere">Save some memories in this profile.</div>
        </div>
      </div>
    `;
  } else {
    filtered.sort((a,b)=> (b.payload.createdAt||"").localeCompare(a.payload.createdAt||""));
    filtered.forEach(x => {
      const p = x.payload;
      const when = fmtDateTime(p.createdAt);

      const whereParts = [];
      if (p.placeLabel) whereParts.push(p.placeLabel);
      if (p.geo) whereParts.push(`GPS: ${p.geo.lat}, ${p.geo.lng}${p.geo.accuracy_m ? " (±"+p.geo.accuracy_m+"m)" : ""}`);
      whereParts.push(`${templateLabel(p.template)} • ${p.source === "upload" ? "Upload" : "Camera"}`);
      const where = whereParts.join(" • ");

      const sharedBadgeHtml = (x.meta && x.meta.sharedByName)
        ? `<div class="badge"><span class="bDot"></span><span>Shared by ${escapeHtml(x.meta.sharedByName)}${x.meta.sharedAt ? " • " + escapeHtml(fmtDateTime(x.meta.sharedAt)) : ""}</span></div>`
        : ``;

      const card = document.createElement("div");
      card.className = "tCard";
      card.setAttribute("data-card-id", x.id);

      const selHtml = selectionMode ? `
              <div class="selWrap">
                <label>Select</label>
                <input type="checkbox" data-sel="${x.id}" ${selectedIds.has(x.id) ? "checked" : ""} />
              </div>` : ``;

      card.innerHTML = `
        <div class="tInner">
          <div class="tThumb"><img src="${p.thumbDataURL}" alt="thumb"/></div>
          <div class="tBody">
            ${selHtml}
            <div>
              <div class="tWhen">${escapeHtml(when)}</div>
              <div class="tWhere">${escapeHtml(where || "—")}</div>
              ${sharedBadgeHtml}
            </div>

            <div class="tPeople">
              ${(p.people || []).length ? (p.people || []).map(n => `<span class="pChip">${escapeHtml(n)}</span>`).join("") : `<span class="pChip">No people tags</span>`}
            </div>

            <div class="tActions">
              <button class="mutedBtn" data-open="${x.id}">Open</button>
              <button class="mutedBtn" data-dl="${x.id}">Download</button>
              <button class="mutedBtn" data-share="${x.id}">Share</button>
              ${p.geo ? `<button class="mutedBtn" data-map="${x.id}">Map</button>` : ``}
              <button class="dangerBtn" data-del="${x.id}">Delete</button>
            </div>
          </div>
        </div>
      `;

      card.querySelector(`[data-open="${x.id}"]`).onclick = () => {
        modalTitle.textContent = `${when}${p.placeLabel ? " • " + p.placeLabel : ""}`;
        modalImg.src = p.finalDataURL;
        modal.style.display = "flex";
      };
      card.querySelector(`[data-dl="${x.id}"]`).onclick = () => {
        const a = document.createElement("a");
        a.download = `memory_${p.createdAt.replace(/[:.]/g,"-")}.jpg`;
        a.href = p.finalDataURL;
        a.click();
      };
      card.querySelector(`[data-share="${x.id}"]`).onclick = async () => {
        await exportSingleMemory(x.id);
      };

      const mapBtn = card.querySelector(`[data-map="${x.id}"]`);
      if (mapBtn) mapBtn.onclick = async () => {
        currentView = "pins";
        setViewButtonUI();
        showMapWrap();
        buildPins(filtered);
        if (p.geo && mapInstance){
          mapInstance.setView([p.geo.lat, p.geo.lng], 16);
        }
      };

      card.querySelector(`[data-del="${x.id}"]`).onclick = async () => {
        await dbDelete(STORE_EVENTS, x.id);
        await refreshTimelineUI();
      };

      // NEW: selection handling
      const sel = card.querySelector(`[data-sel="${x.id}"]`);
      if (sel){
        sel.onchange = () => {
          if (sel.checked) selectedIds.add(x.id);
          else selectedIds.delete(x.id);
          setSelectionButtonsUI();
        };
      }

      timelineGrid.appendChild(card);
    });
  }

  if (currentView === "pins"){
    showMapWrap();
    buildPins(filtered);
  } else if (currentView === "heat"){
    showMapWrap();
    buildHeat(filtered);
  } else {
    showListView();
  }
}

/* =========================================================
   Tabs
========================================================= */
function showBooth(){
  boothView.style.display = "";
  timelineView.style.display = "none";
  tabBooth.classList.add("active");
  tabTimeline.classList.remove("active");
}
async function showTimeline(){
  if (!isUnlocked()) return;
  boothView.style.display = "none";
  timelineView.style.display = "";
  tabBooth.classList.remove("active");
  tabTimeline.classList.add("active");
  currentView = "list";
  setViewButtonUI();
  await refreshTimelineUI();
}

/* =========================================================
   Profiles (Gate)
========================================================= */
async function listProfiles(){
  const profiles = await dbGetAll(STORE_PROFILES);
  profiles.sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""));
  profilesGrid.innerHTML = "";

  if (profiles.length === 0){
    noProfiles.style.display = "";
    return profiles;
  } else {
    noProfiles.style.display = "none";
  }

  profiles.forEach(p => {
    const btn = document.createElement("button");
    btn.className = "profileBtn";
    btn.type = "button";
    btn.innerHTML = `
      <div>
        <div class="name">${escapeHtml(p.name)}</div>
        <div class="meta">Created: ${new Date(p.createdAt).toLocaleDateString()}</div>
      </div>
      <div class="meta">Unlock</div>
    `;
    btn.onclick = () => unlockProfileFlow(p);
    profilesGrid.appendChild(btn);
  });

  return profiles;
}

function openGate(){
  gate.style.display = "flex";
  createMsg.textContent = "";
  importMsg.textContent = "";
  newName.value = "";
  newPin.value = "";
  listProfiles();
}
function closeGate(){ gate.style.display = "none"; }

async function createProfile(){
  const name = (newName.value || "").trim();
  const pin = (newPin.value || "").trim();
  if (!name){ createMsg.textContent = "Name required."; return; }
  if (!/^\d{4,12}$/.test(pin)){ createMsg.textContent = "PIN must be 4–12 digits."; return; }

  const profiles = await dbGetAll(STORE_PROFILES);
  if (profiles.some(p => (p.name||"").toLowerCase() === name.toLowerCase())){
    createMsg.textContent = "Name already exists.";
    return;
  }

  const salt = randBytes(16);
  const saltB64 = ab2b64(salt.buffer);
  const iterations = 150000;

  const bits = await deriveBits(pin, saltB64, iterations);
  const vhash = await sha256(bits);
  const verifierB64 = ab2b64(vhash);

  const profile = {
    id: crypto.randomUUID(),
    name,
    createdAt: nowISO(),
    saltB64,
    verifierB64,
    iterations
  };
  await dbPut(STORE_PROFILES, profile);
  createMsg.textContent = "Created. Unlock it from the left.";
  await listProfiles();
}

async function unlockProfileFlow(p){
  const pin = prompt(`Enter PIN for ${p.name}:`);
  if (!pin) return;
  if (!/^\d{4,12}$/.test(pin)){ alert("Invalid PIN format."); return; }

  wipeAllVisuals();
  stopCamera();

  const bits = await deriveBits(pin, p.saltB64, p.iterations || 150000);
  const vhash = await sha256(bits);
  const vB64 = ab2b64(vhash);

  if (vB64 !== p.verifierB64){
    alert("Wrong PIN.");
    return;
  }

  sessionKey = await deriveAesKey(pin, p.saltB64, p.iterations || 150000);
  activeProfileId = p.id;
  activeProfileName = p.name;

  closeGate();
  setSessionUI();
  await refreshPeopleSources();
}

function lockNow(){
  wipeAllVisuals();
  stopCamera();

  activeProfileId = null;
  activeProfileName = null;
  sessionKey = null;

  showBooth();
  tabTimeline.disabled = true;
  setSessionUI();

  currentView = "list";
  setViewButtonUI();
}

/* =========================================================
   Export / Import Vault (whole profile) - unchanged
========================================================= */
async function exportActiveVault(){
  if (!isUnlocked()) return;

  const profile = await dbGet(STORE_PROFILES, activeProfileId);
  if (!profile) { alert("Profile not found."); return; }

  const encEvents = await getMyEventsEncrypted();

  const payload = {
    format: "VPB_VAULT_EXPORT_V1",
    exportedAt: nowISO(),
    profile: {
      id: profile.id,
      name: profile.name,
      createdAt: profile.createdAt,
      saltB64: profile.saltB64,
      verifierB64: profile.verifierB64,
      iterations: profile.iterations || 150000
    },
    events: encEvents.map(e => ({
      id: e.id,
      profileId: e.profileId,
      createdAt: e.createdAt,
      enc: e.enc,
      meta: e.meta || null
    }))
  };

  const json = JSON.stringify(payload);
  const blob = new Blob([json], { type:"application/json" });

  const fileName = `${safeFileName(profile.name)}_vault_${new Date().toISOString().slice(0,10)}.vpb.json`;
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  a.click();

  setTimeout(() => URL.revokeObjectURL(url), 2000);
}

function pickImportFile(){
  importMsg.textContent = "";
  importFile.value = "";
  importFile.click();
}
async function readFileAsText(file){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(String(fr.result || ""));
    fr.onerror = () => reject(fr.error);
    fr.readAsText(file);
  });
}
async function importVaultFromFile(file){
  try{
    importMsg.textContent = "Importing…";
    const txt = await readFileAsText(file);
    const data = JSON.parse(txt);

    if (!data || data.format !== "VPB_VAULT_EXPORT_V1"){
      importMsg.textContent = "Invalid file format.";
      return;
    }
    if (!data.profile || !data.profile.name || !data.profile.saltB64 || !data.profile.verifierB64){
      importMsg.textContent = "Missing profile data.";
      return;
    }

    const profiles = await dbGetAll(STORE_PROFILES);
    const lower = (s)=> String(s||"").toLowerCase();
    const taken = new Set(profiles.map(p => lower(p.name)));

    const baseName = String(data.profile.name).trim() || "Imported";
    let finalName = baseName;
    let k = 1;
    while (taken.has(lower(finalName))){
      k++;
      finalName = `${baseName} (Imported ${k})`;
    }

    const newProfileId = crypto.randomUUID();
    const newProfile = {
      id: newProfileId,
      name: finalName,
      createdAt: data.profile.createdAt || nowISO(),
      saltB64: data.profile.saltB64,
      verifierB64: data.profile.verifierB64,
      iterations: data.profile.iterations || 150000,
      importedAt: nowISO()
    };

    const existingEvents = await dbGetAll(STORE_EVENTS);
    const usedEventIds = new Set(existingEvents.map(e => e.id));

    await dbPut(STORE_PROFILES, newProfile);

    const events = Array.isArray(data.events) ? data.events : [];
    let importedCount = 0;

    for (const e of events){
      if (!e || !e.enc || !e.enc.ivB64 || !e.enc.ctB64) continue;

      let newEventId = (typeof e.id === "string" && e.id) ? e.id : crypto.randomUUID();
      while (usedEventIds.has(newEventId)) newEventId = crypto.randomUUID();
      usedEventIds.add(newEventId);

      const rec = {
        id: newEventId,
        profileId: newProfileId,
        createdAt: e.createdAt || nowISO(),
        enc: { ivB64: e.enc.ivB64, ctB64: e.enc.ctB64 },
        meta: e.meta || null
      };
      await dbPut(STORE_EVENTS, rec);
      importedCount++;
    }

    importMsg.textContent = `Imported: ${finalName} • ${importedCount} memories`;
    await listProfiles();

  } catch (_){
    importMsg.textContent = "Import failed.";
  }
}

/* =========================================================
   NEW: Share single memory (export) + Import into current profile
========================================================= */
async function exportSingleMemory(eventId){
  if (!isUnlocked()) return;

  const e = await dbGet(STORE_EVENTS, eventId);
  if (!e) { alert("Memory not found."); return; }
  if (e.profileId !== activeProfileId) { alert("Not in your active vault."); return; }
  if (!e.enc || !e.enc.ivB64 || !e.enc.ctB64) { alert("Corrupt memory."); return; }

  // ✅ Decrypt using sender's session key (works only while sender is unlocked)
  let plain;
  try{
    plain = await decryptJSON(sessionKey, e.enc.ivB64, e.enc.ctB64);
  } catch(_){
    alert("Unable to decrypt this memory in current session.");
    return;
  }

  // ✅ Export plaintext so receiver can re-encrypt into THEIR vault
  const payload = {
    format: "VPB_MEMORY_EXPORT_V2",
    exportedAt: nowISO(),
    sharedByName: activeProfileName || "Unknown",
    memory: {
      createdAt: plain.createdAt || e.createdAt || nowISO(),
      payload: plain
    }
  };

  const json = JSON.stringify(payload);
  const blob = new Blob([json], { type:"application/json" });
  const url = URL.createObjectURL(blob);

  const fileName = `${safeFileName(activeProfileName)}_memory_${String(e.createdAt||nowISO()).slice(0,10)}.vpb.memory.json`;
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  a.click();

  setTimeout(() => URL.revokeObjectURL(url), 2000);
}


function pickImportMemoryFile(){
  if (!isUnlocked()) return;
  importMemoryFile.value = "";
  importMemoryFile.click();
}

async function importSingleMemoryIntoActiveProfile(file){
  if (!isUnlocked()) return;

  try{
    const txt = await readFileAsText(file);
    const data = JSON.parse(txt);

    const isSingle = data && data.format === "VPB_MEMORY_EXPORT_V2";
    const isBundle = data && data.format === "VPB_MEMORY_BUNDLE_EXPORT_V2";

    if (!isSingle && !isBundle){
      alert("Invalid memory file.");
      return;
    }

    const sharedByName = (data.sharedByName || "").trim() || "Unknown";
    const sharedAt = data.exportedAt || nowISO();

    const items = isSingle
      ? [data.memory]
      : (Array.isArray(data.memories) ? data.memories : []);

    const valid = items.filter(p => p && p.finalDataURL && p.thumbDataURL);
    if (valid.length === 0){
      alert("Invalid memory payload.");
      return;
    }

    const existingEvents = await dbGetAll(STORE_EVENTS);
    const usedEventIds = new Set(existingEvents.map(e => e.id));

    let imported = 0;

    for (const payload of valid){
      const enc = await encryptJSON(sessionKey, payload);

      let newEventId = crypto.randomUUID();
      while (usedEventIds.has(newEventId)) newEventId = crypto.randomUUID();
      usedEventIds.add(newEventId);

      const rec = {
        id: newEventId,
        profileId: activeProfileId,
        createdAt: payload.createdAt || nowISO(),
        enc,
        meta: {
          sharedByName,
          sharedAt,
          importedAt: nowISO(),
          type: "imported_memory"
        }
      };

      await dbPut(STORE_EVENTS, rec);
      imported++;
    }

    await refreshTimelineUI();
    await refreshPeopleSources();

    alert(`Imported ${imported} memory${imported===1?"":"ies"} into ${activeProfileName}. Shared by ${sharedByName}.`);
  } catch(_){
    alert("Import failed.");
  }
}


/* =========================================================
   People suggestions (per vault)
========================================================= */
/* (per vault)
========================================================= */
function buildPeopleSuggestions(allPeople){
  const unique = Array.from(new Set(allPeople.map(p => p.trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
  peopleSuggestions.innerHTML = "";
  unique.slice(0, 18).forEach(name => {
    const b = document.createElement("button");
    b.className = "chip";
    b.type = "button";
    b.textContent = name;
    b.onclick = () => {
      const current = sanitizePeopleInput(peopleInput.value);
      if (!current.includes(name)) current.push(name);
      peopleInput.value = current.join(", ");
    };
    peopleSuggestions.appendChild(b);
  });
}
async function refreshPeopleSources(){
  if (!isUnlocked()){
    peopleSuggestions.innerHTML = "";
    return;
  }
  const encEvents = await getMyEventsEncrypted();
  const dec = await decryptMany(encEvents);
  const all = [];
  dec.forEach(x => (x.payload.people || []).forEach(p => all.push(p)));
  buildPeopleSuggestions(all);
}

/* =========================================================
   Listeners
========================================================= */
tabBooth.onclick = showBooth;
tabTimeline.onclick = showTimeline;

startBtn.onclick = async () => { await startCamera(); };
flipBtn.onclick = async () => {
  facingMode = (facingMode === "user") ? "environment" : "user";
  startBtn.disabled = false;
  startBtn.textContent = "Restart Camera";
  await startCamera();
};
shootBtn.onclick = async () => { await takeBurst(); };
uploadBtn.onclick = async () => { await pickUpload3(); };
uploadFiles.onchange = async () => {
  const fs = uploadFiles.files;
  if (!fs || fs.length === 0) return;
  await handleUploadFiles(fs);
};

retakeBtn.onclick = () => { wipeAllVisuals(); setSessionUI(); };
makeBtn.onclick = async () => { await generate(); };
downloadBtn.onclick = download;
printBtn.onclick = printCard;

geoBtn.onclick = async () => {
  geoStatus.textContent = "GPS: capturing…";
  geoData = await getGeo();
  if (!geoData){
    geoStatus.textContent = "GPS: denied/unavailable";
    geoData = null;
  } else {
    geoStatus.textContent = `GPS: ${geoData.lat}, ${geoData.lng} (±${geoData.accuracy_m}m)`;
  }
};

pickOnMapBtn.onclick = () => openGeoPicker();
geoPickClose.onclick = () => closeGeoPicker();
geoPickClear.onclick = () => clearGeoPick();
geoPickSave.onclick = () => saveGeoPick();
geoModal.onclick = (e) => { if (e.target === geoModal) closeGeoPicker(); };

saveBtn.onclick = async () => {
  if (!isUnlocked()) return;
  saveBtn.disabled = true;
  await saveMemory();
  await refreshPeopleSources();
  saveBtn.disabled = false;
  setSessionUI();
};

viewListBtn.onclick = async () => { currentView = "list"; setViewButtonUI(); await refreshTimelineUI(); };
viewPinsBtn.onclick = async () => { currentView = "pins"; setViewButtonUI(); await refreshTimelineUI(); };
viewHeatBtn.onclick = async () => { currentView = "heat"; setViewButtonUI(); await refreshTimelineUI(); };

refreshTimeline.onclick = async () => { if (isUnlocked()) await refreshTimelineUI(); };
personFilter.onchange = async () => { if (isUnlocked()) await refreshTimelineUI(); };
searchFilter.oninput = async () => { if (isUnlocked()) await refreshTimelineUI(); };

exportMyVaultBtn.onclick = async () => { await exportActiveVault(); };

clearAll.onclick = async () => {
  if (!isUnlocked()) return;
  const ok = confirm(`Clear ALL memories for ${activeProfileName}?`);
  if (!ok) return;
  await dbClearWhereProfile(activeProfileId);
  await refreshTimelineUI();
  await refreshPeopleSources();
};

modalClose.onclick = () => { modal.style.display = "none"; };
modal.onclick = (e) => { if (e.target === modal) modal.style.display = "none"; };

// switch profile = wipe + stop + open gate
switchProfileBtn.onclick = () => {
  wipeAllVisuals();
  stopCamera();
  openGate();
};

lockBtn.onclick = () => lockNow();

// guest = wipe + stop + clear session + close gate
gateClose.onclick = () => {
  wipeAllVisuals();
  stopCamera();
  activeProfileId = null;
  activeProfileName = null;
  sessionKey = null;
  tabTimeline.disabled = true;
  showBooth();
  setSessionUI();
  closeGate();
};

createProfileBtn.onclick = async () => { await createProfile(); };

importVaultBtn.onclick = () => pickImportFile();
importFile.onchange = async () => {
  const f = importFile.files && importFile.files[0];
  if (!f) return;
  await importVaultFromFile(f);
};

/* NEW: multi-select export */
selectModeBtn.onclick = async () => { toggleSelectionMode(); await refreshTimelineUI(); };
selectAllBtn.onclick = async () => { selectAllFiltered(); await refreshTimelineUI(); };
clearSelectionBtn.onclick = async () => { clearSelection(); await refreshTimelineUI(); };
exportSelectedBtn.onclick = async () => { await exportSelectedMemories(); };

/* NEW: import shared memory into current unlocked profile */
importMemoryBtn.onclick = () => pickImportMemoryFile();
importMemoryFile.onchange = async () => {
  const f = importMemoryFile.files && importMemoryFile.files[0];
  if (!f) return;
  await importSingleMemoryIntoActiveProfile(f);
};

/* =========================================================
   Boot
========================================================= */
(async function init(){
  setViewButtonUI();
  wipeAllVisuals();
  stopCamera();
  setSessionUI();
  openGate();
})();
</script>
</body>
</html>
