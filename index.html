<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vintage Photobooth + Private Memories</title>

  <!-- Leaflet (Map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- MarkerCluster (Pins clustering) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>

  <style>
    :root{
      --paper:#f6f1e7;
      --ink:#171717;
      --muted:#6b6256;
      --accent:#6a4b2f;
      --shadow: 0 18px 50px rgba(0,0,0,.12);
      --radius: 18px;
      --line: rgba(0,0,0,.10);
      --danger:#b91c1c;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 600px at 50% 10%, #fff8ee 0%, var(--paper) 55%, #efe6d7 100%);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .shell{width:min(1120px,100%); display:grid; gap:14px;}
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 6px;
      flex-wrap:wrap;
    }
    .brand{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900; letter-spacing:.4px; font-size:22px;
      display:flex; gap:10px; align-items:baseline;
    }
    .hint{color:var(--muted); font-size:13px;}
    .tabs{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .tabBtn{
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.72);
      padding:10px 14px;
      font-size:13px;
      cursor:pointer;
    }
    .tabBtn.active{
      background:var(--accent);
      color:#fff;
      border-color: rgba(0,0,0,.12);
    }
    .tabBtn:disabled{opacity:.5; cursor:not-allowed;}

    .rightBar{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .sessionPill{
      display:flex; gap:8px; align-items:center;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.68);
      border-radius:999px;
      padding:7px 10px;
      font-size:12px;
      color:rgba(0,0,0,.78);
    }
    .dot{
      width:10px;height:10px;border-radius:999px;background:#999;
      box-shadow:0 6px 14px rgba(0,0,0,.10);
    }
    .dot.green{background:#16a34a;}
    .dot.red{background:#ef4444;}

    .card{
      background:rgba(255,255,255,.72);
      backdrop-filter: blur(8px);
      border:1px solid rgba(0,0,0,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .content{display:grid; grid-template-columns: 1.15fr .85fr; gap:0;}
    @media (max-width: 980px){ .content{grid-template-columns:1fr} }
    .stage{padding:18px; border-right:1px solid rgba(0,0,0,.06);}
    @media (max-width: 980px){ .stage{border-right:none;border-bottom:1px solid rgba(0,0,0,.06)} }
    .side{padding:18px; display:grid; gap:12px; align-content:start;}
    .panelTitle{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-size:18px; font-weight:900; margin:0 0 8px;
    }
    .sub{margin:0 0 12px; color:var(--muted); font-size:13px; line-height:1.45;}
    .previewWrap{
      background:rgba(255,255,255,.8);
      border:1px solid rgba(0,0,0,.08);
      border-radius:16px;
      padding:14px;
      display:grid;
      gap:10px;
    }
    video, canvas{
      width:100%;
      border-radius:14px;
      background:#000;
      display:block;
    }
    .controls{display:flex; gap:10px; flex-wrap:wrap;}
    button, select, input{
      border-radius: 14px;
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      padding:11px 12px;
      font-size:14px;
      outline:none;
    }
    button{cursor:pointer;}
    button.primary{background:#6a4b2f; color:#fff;}
    button.ghost{background:transparent;}
    button:disabled{opacity:.55; cursor:not-allowed;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.7);
      padding:7px 10px;
      border-radius:999px;
    }
    .countdown{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
      font-size:56px;
      line-height:1;
      color:rgba(26,26,26,.92);
      text-align:center;
      margin:8px 0 0;
      display:none;
    }
    .miniGrid{display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;}
    .thumb{
      border-radius:12px;
      border:1px solid rgba(0,0,0,.10);
      overflow:hidden;
      background:#000;
      aspect-ratio: 4/3;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block; opacity:.92;}
    .footerNote{
      padding:14px 18px;
      border-top:1px solid rgba(0,0,0,.06);
      color:var(--muted);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .metaGrid{display:grid; gap:10px;}
    .smallLabel{font-size:12px; color:var(--muted); margin:0 0 6px;}
    .chipRow{display:flex; gap:8px; flex-wrap:wrap;}
    .chip{
      border:1px solid var(--line);
      background:rgba(255,255,255,.7);
      color:rgba(26,26,26,.85);
      padding:7px 10px;
      border-radius:999px;
      font-size:12px;
      cursor:pointer;
    }

    /* Timeline */
    .timelineWrap{padding:18px;}
    .timelineHeader{
      display:flex; gap:12px; align-items:end; justify-content:space-between; flex-wrap:wrap;
      padding:6px 6px 14px;
      border-bottom:1px solid rgba(0,0,0,.06);
    }
    .timelineTitle{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900; font-size:20px;
    }
    .filters{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .filters input, .filters select{background:rgba(255,255,255,.8);}
    .timelineGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      padding:16px 6px 8px;
    }
    .tCard{
      position:relative;
      background:rgba(255,255,255,.82);
      border:1px solid rgba(0,0,0,.08);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 26px rgba(0,0,0,.09);
    }
    .tInner{display:grid; grid-template-columns: 220px 1fr;}
    @media (max-width: 760px){ .tInner{grid-template-columns: 1fr;} }
    .tThumb{
      background:#111;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:160px;
      border-right:1px solid rgba(0,0,0,.08);
    }
    @media (max-width: 760px){
      .tThumb{border-right:none;border-bottom:1px solid rgba(0,0,0,.08)}
    }
    .tThumb img{width:100%; height:100%; object-fit:cover; display:block; opacity:.95;}
    .tBody{padding:14px;}
    .tWhen{font-weight:800; font-size:14px;}
    .tWhere{color:var(--muted); font-size:12px; margin-top:6px; line-height:1.35;}
    .tPeople{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .pChip{
      border:1px solid rgba(0,0,0,.10);
      background:rgba(246,241,231,.8);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:rgba(26,26,26,.80);
    }
    .tActions{margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;}
    .tActions button{padding:10px 12px; font-size:13px; border-radius:12px;}
    .dangerBtn{
      border-color: rgba(220,38,38,.30);
      color:var(--danger);
      background:rgba(255,255,255,.85);
    }
    .mutedBtn{background:rgba(255,255,255,.85);}
    .tCard::before{
      content:"";
      position:absolute;
      left:-26px; top:0; bottom:0;
      width:2px;
      background:rgba(0,0,0,.08);
    }
    .tCard::after{
      content:"";
      position:absolute;
      left:-33px;
      top:26px;
      width:16px; height:16px;
      border-radius:999px;
      background:#6a4b2f;
      box-shadow:0 8px 16px rgba(0,0,0,.12);
    }
    .timelineRail{position:relative; padding-left:34px;}
    .timelineRail::before{
      content:"";
      position:absolute;
      left:7px; top:0; bottom:0;
      width:2px;
      background:rgba(0,0,0,.06);
    }

    /* Map */
    #map { background:#eaeaea; }

    /* Modal */
    .modal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .modalCard{
      width:min(980px, 96vw);
      background:rgba(255,255,255,.92);
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:0 20px 60px rgba(0,0,0,.25);
    }
    .modalHead{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(0,0,0,.08);
    }
    .modalHead .title{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
    }
    .modalBody{padding:14px; background:#111;}
    .modalBody img{width:100%; height:auto; display:block;}

    /* Profile Gate */
    .gate{
      position:fixed; inset:0;
      background:radial-gradient(900px 500px at 50% 10%, rgba(255,248,238,.35), rgba(0,0,0,.62));
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:80;
    }
    .gateCard{
      width:min(920px, 96vw);
      background:rgba(255,255,255,.92);
      border-radius:18px;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:0 20px 60px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .gateHead{
      padding:14px 16px;
      border-bottom:1px solid rgba(0,0,0,.08);
      display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
    }
    .gateTitle{
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-weight:900;
      font-size:18px;
    }
    .gateBody{
      padding:16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 820px){ .gateBody{grid-template-columns:1fr} }
    .box{
      border:1px solid rgba(0,0,0,.10);
      border-radius:16px;
      background:rgba(255,255,255,.75);
      padding:14px;
    }
    .profilesGrid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(2, minmax(0,1fr));
    }
    @media (max-width: 520px){ .profilesGrid{grid-template-columns:1fr} }
    .profileBtn{
      text-align:left;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.85);
      cursor:pointer;
    }
    .profileBtn .name{font-weight:900;}
    .profileBtn .meta{font-size:12px;color:rgba(0,0,0,.55);}
  </style>
</head>

<body>
  <div class="shell">
    <div class="top">
      <div class="brand">
        <span>Vintage Photobooth</span>
        <span class="hint">Profiles + PIN → private timeline per person</span>
      </div>

      <div class="rightBar">
        <div class="sessionPill" id="sessionPill">
          <span id="statusDot" class="dot red"></span>
          <span id="sessionText">Guest (locked)</span>
        </div>
        <button id="switchProfileBtn" class="mutedBtn">Switch Profile</button>
        <button id="lockBtn" class="dangerBtn" style="display:none;">Lock</button>
      </div>

      <div class="tabs">
        <button id="tabBooth" class="tabBtn active">Photobooth</button>
        <button id="tabTimeline" class="tabBtn" disabled>Timeline</button>
      </div>
    </div>

    <div id="boothView" class="card">
      <div class="content">
        <div class="stage">
          <div class="previewWrap">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="out" width="1400" height="2000" style="display:none"></canvas>

            <div class="controls">
              <button id="startBtn" class="primary">Start Camera</button>
              <button id="flipBtn" class="ghost" disabled>Flip</button>
              <button id="shootBtn" class="primary" disabled>Take 3 Photos</button>
              <button id="retakeBtn" class="ghost" disabled>Retake</button>
              <button id="downloadBtn" class="primary" disabled>Download</button>
              <button id="printBtn" class="ghost" disabled>Print</button>
            </div>

            <div class="row">
              <span class="pill">Template</span>
              <select id="template">
                <option value="strip">Photo Strip (3 frames)</option>
                <option value="postcard3">Postcard Collage</option>
                <option value="film3">Film Border</option>
              </select>
              <span class="pill">Caption</span>
              <input id="caption" placeholder="e.g., Yash & Friends" />
            </div>

            <div id="countdown" class="countdown">3</div>
          </div>
        </div>

        <div class="side">
          <div>
            <div class="panelTitle">Your 3 shots</div>
            <p class="sub">Download always works. Save-to-Timeline needs unlock (profile PIN).</p>
          </div>

          <div id="thumbs" class="miniGrid"></div>

          <div class="row">
            <span class="pill">Vintage</span>
            <input id="strength" type="range" min="0" max="100" value="65" style="flex:1" />
          </div>
          <div class="row">
            <span class="pill">Grain</span>
            <input id="grain" type="range" min="0" max="100" value="35" style="flex:1" />
          </div>
          <div class="row">
            <span class="pill">Date stamp</span>
            <select id="datestamp">
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>

          <button id="makeBtn" class="primary" disabled>Generate Template</button>

          <div class="metaGrid">
            <div>
              <div class="smallLabel">People (comma-separated)</div>
              <input id="peopleInput" placeholder="e.g., Aditi, Rohan, Mom" />
              <div class="smallLabel" style="margin-top:8px;">Quick pick (your vault)</div>
              <div id="peopleSuggestions" class="chipRow"></div>
            </div>

            <div>
              <div class="smallLabel">Location label (optional)</div>
              <input id="placeLabel" placeholder="e.g., DLF Mall / Wedding Venue" />
            </div>

            <div class="row">
              <button id="geoBtn" class="mutedBtn">Get GPS</button>
              <span id="geoStatus" class="pill">GPS: not captured</span>
            </div>

            <button id="saveBtn" class="primary" disabled>Save to Timeline (Locked)</button>
          </div>

          <p class="sub" id="saveHint">Generate output first. Then unlock to save.</p>
        </div>
      </div>

      <div class="footerNote">
        <span>Local-only vaults. Encrypted on this device.</span>
        <span>Tip: unlock only for the owner.</span>
      </div>
    </div>

    <div id="timelineView" class="card" style="display:none;">
      <div class="timelineWrap">
        <div class="timelineHeader">
          <div>
            <div class="timelineTitle">Memories Timeline</div>
            <div class="hint">List / Pins / Heat. Only your unlocked vault.</div>
          </div>
          <div class="filters">
            <button id="viewListBtn" class="mutedBtn">List</button>
            <button id="viewPinsBtn" class="mutedBtn">Pins</button>
            <button id="viewHeatBtn" class="mutedBtn">Heat</button>

            <select id="personFilter">
              <option value="">All people</option>
            </select>
            <input id="searchFilter" placeholder="Search place / caption" />
            <button id="refreshTimeline" class="mutedBtn">Refresh</button>
            <button id="clearAll" class="dangerBtn">Clear My Vault</button>
          </div>
        </div>

        <div class="timelineRail">
          <div id="timelineGrid" class="timelineGrid"></div>

          <div id="mapWrap" style="display:none; padding:16px 6px 8px;">
            <div id="map" style="height:520px; border-radius:16px; border:1px solid rgba(0,0,0,.08); overflow:hidden;"></div>
            <div class="hint" style="margin-top:10px;">Pins/Heat show GPS memories only.</div>
          </div>
        </div>
      </div>
      <div class="footerNote">
        <span>Encrypted + local.</span>
        <span id="stats">—</span>
      </div>
    </div>
  </div>

  <!-- Full image modal -->
  <div id="modal" class="modal">
    <div class="modalCard">
      <div class="modalHead">
        <div class="title" id="modalTitle">Memory</div>
        <button id="modalClose" class="mutedBtn">Close</button>
      </div>
      <div class="modalBody">
        <img id="modalImg" alt="memory" />
      </div>
    </div>
  </div>

  <!-- Profile Gate -->
  <div id="gate" class="gate">
    <div class="gateCard">
      <div class="gateHead">
        <div>
          <div class="gateTitle">Choose a profile</div>
          <div class="hint">Each profile is a private vault protected by PIN.</div>
        </div>
        <button id="gateClose" class="mutedBtn">Continue as Guest</button>
      </div>

      <div class="gateBody">
        <div class="box">
          <div class="panelTitle">Existing profiles</div>
          <div class="hint" style="margin-top:-6px;">Tap a profile → enter PIN → unlock timeline.</div>
          <div style="height:10px"></div>
          <div id="profilesGrid" class="profilesGrid"></div>
          <div id="noProfiles" class="hint" style="display:none; margin-top:10px;">No profiles yet. Create one on the right.</div>
        </div>

        <div class="box">
          <div class="panelTitle">Create new profile</div>
          <div class="hint" style="margin-top:-6px;">Use a PIN you will remember. No recovery.</div>
          <div style="height:10px"></div>

          <div class="smallLabel">Profile name</div>
          <input id="newName" placeholder="e.g., Yash" />

          <div style="height:10px"></div>
          <div class="smallLabel">PIN (4–12 digits)</div>
          <input id="newPin" type="password" inputmode="numeric" placeholder="••••" />

          <div style="height:10px"></div>
          <div class="row">
            <button id="createProfileBtn" class="primary">Create</button>
            <span id="createMsg" class="hint"></span>
          </div>

          <div style="height:14px"></div>
          <div class="hint">
            Guest mode: you can still take photos + download/print, but you can’t save or view timeline.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <!-- Heatmap plugin -->
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

<script>
/* =========================================================
   DB (IndexedDB)
========================================================= */
const DB_NAME = "vintage_photobooth_db";
const DB_VER  = 2;
const STORE_EVENTS   = "events";   // encrypted memories
const STORE_PROFILES = "profiles"; // profile metadata

function openDB(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = () => {
      const db = req.result;

      if (!db.objectStoreNames.contains(STORE_PROFILES)) {
        const p = db.createObjectStore(STORE_PROFILES, { keyPath: "id" });
        p.createIndex("createdAt", "createdAt", { unique:false });
        p.createIndex("name", "name", { unique:false });
      }

      if (!db.objectStoreNames.contains(STORE_EVENTS)) {
        const e = db.createObjectStore(STORE_EVENTS, { keyPath: "id" });
        e.createIndex("profileId", "profileId", { unique:false });
        e.createIndex("createdAt", "createdAt", { unique:false });
      } else {
        const store = req.transaction.objectStore(STORE_EVENTS);
        if (!store.indexNames.contains("profileId")) store.createIndex("profileId", "profileId", { unique:false });
        if (!store.indexNames.contains("createdAt")) store.createIndex("createdAt", "createdAt", { unique:false });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function dbPut(storeName, obj){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).put(obj);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}
async function dbGetAll(storeName){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
async function dbDelete(storeName, id){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).delete(id);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}
async function dbClearWhereProfile(profileId){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_EVENTS, "readwrite");
    const store = tx.objectStore(STORE_EVENTS);
    const idx = store.index("profileId");
    const range = IDBKeyRange.only(profileId);
    const req = idx.openCursor(range);
    req.onsuccess = () => {
      const cursor = req.result;
      if (cursor) {
        cursor.delete();
        cursor.continue();
      }
    };
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

/* =========================================================
   Helpers
========================================================= */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function nowISO(){ return new Date().toISOString(); }
function fmtDateTime(iso){
  const d = new Date(iso);
  return d.toLocaleString(undefined, { weekday:"short", year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
}
function sanitizePeopleInput(s){
  return (s || "").split(",").map(x => x.trim()).filter(Boolean).slice(0, 10);
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function canvasToDataURL(canvas, quality=0.92){
  return canvas.toDataURL("image/jpeg", quality);
}

function ab2b64(buf){
  const bytes = new Uint8Array(buf);
  let bin = "";
  for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}
function b642ab(b64){
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  return bytes.buffer;
}
function randBytes(n){
  const a = new Uint8Array(n);
  crypto.getRandomValues(a);
  return a;
}
async function sha256(ab){
  return crypto.subtle.digest("SHA-256", ab);
}
async function importRawKeyFromPin(pin){
  return crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(pin),
    { name:"PBKDF2" },
    false,
    ["deriveKey","deriveBits"]
  );
}
async function deriveAesKey(pin, saltB64, iterations=150000){
  const salt = new Uint8Array(b642ab(saltB64));
  const baseKey = await importRawKeyFromPin(pin);
  return crypto.subtle.deriveKey(
    { name:"PBKDF2", salt, iterations, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}
async function deriveBits(pin, saltB64, iterations=150000){
  const salt = new Uint8Array(b642ab(saltB64));
  const baseKey = await importRawKeyFromPin(pin);
  const bits = await crypto.subtle.deriveBits(
    { name:"PBKDF2", salt, iterations, hash:"SHA-256" },
    baseKey,
    256
  );
  return bits;
}
async function encryptJSON(aesKey, obj){
  const iv = randBytes(12);
  const pt = new TextEncoder().encode(JSON.stringify(obj));
  const ct = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, pt);
  return { ivB64: ab2b64(iv.buffer), ctB64: ab2b64(ct) };
}
async function decryptJSON(aesKey, ivB64, ctB64){
  const iv = new Uint8Array(b642ab(ivB64));
  const ct = b642ab(ctB64);
  const pt = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, ct);
  const txt = new TextDecoder().decode(pt);
  return JSON.parse(txt);
}
function escapeHtml(s){
  return (s||"").replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]));
}

/* =========================================================
   UI refs
========================================================= */
const tabBooth = document.getElementById("tabBooth");
const tabTimeline = document.getElementById("tabTimeline");
const boothView = document.getElementById("boothView");
const timelineView = document.getElementById("timelineView");

const statusDot = document.getElementById("statusDot");
const sessionText = document.getElementById("sessionText");
const switchProfileBtn = document.getElementById("switchProfileBtn");
const lockBtn = document.getElementById("lockBtn");

const video = document.getElementById('video');
const out = document.getElementById('out');
const ctxOut = out.getContext('2d');

const startBtn = document.getElementById('startBtn');
const flipBtn = document.getElementById('flipBtn');
const shootBtn = document.getElementById('shootBtn');
const retakeBtn = document.getElementById('retakeBtn');
const makeBtn = document.getElementById('makeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const printBtn = document.getElementById('printBtn');
const saveBtn = document.getElementById('saveBtn');

const thumbs = document.getElementById('thumbs');
const countdownEl = document.getElementById('countdown');

const templateSel = document.getElementById('template');
const captionInp = document.getElementById('caption');
const strengthInp = document.getElementById('strength');
const grainInp = document.getElementById('grain');
const datestampSel = document.getElementById('datestamp');

const peopleInput = document.getElementById("peopleInput");
const peopleSuggestions = document.getElementById("peopleSuggestions");
const placeLabel = document.getElementById("placeLabel");

const geoBtn = document.getElementById("geoBtn");
const geoStatus = document.getElementById("geoStatus");
let geoData = null;

const saveHint = document.getElementById("saveHint");

/* Timeline refs */
const viewListBtn = document.getElementById("viewListBtn");
const viewPinsBtn = document.getElementById("viewPinsBtn");
const viewHeatBtn = document.getElementById("viewHeatBtn");
const mapWrap = document.getElementById("mapWrap");
const mapEl = document.getElementById("map");

const personFilter = document.getElementById("personFilter");
const searchFilter = document.getElementById("searchFilter");
const refreshTimeline = document.getElementById("refreshTimeline");
const clearAll = document.getElementById("clearAll");
const timelineGrid = document.getElementById("timelineGrid");
const stats = document.getElementById("stats");

/* Modal */
const modal = document.getElementById("modal");
const modalTitle = document.getElementById("modalTitle");
const modalImg = document.getElementById("modalImg");
const modalClose = document.getElementById("modalClose");

/* Gate */
const gate = document.getElementById("gate");
const gateClose = document.getElementById("gateClose");
const profilesGrid = document.getElementById("profilesGrid");
const noProfiles = document.getElementById("noProfiles");
const newName = document.getElementById("newName");
const newPin = document.getElementById("newPin");
const createProfileBtn = document.getElementById("createProfileBtn");
const createMsg = document.getElementById("createMsg");

/* =========================================================
   Session state (in-memory)
========================================================= */
let activeProfileId = null;
let activeProfileName = null;
let sessionKey = null; // AES-GCM CryptoKey, only when unlocked

function isUnlocked(){
  return !!(activeProfileId && sessionKey);
}

function setSessionUI(){
  if (isUnlocked()){
    statusDot.classList.remove("red"); statusDot.classList.add("green");
    sessionText.textContent = `${activeProfileName} (unlocked)`;
    lockBtn.style.display = "";
    tabTimeline.disabled = false;
    saveBtn.disabled = (out.style.display === "none") ? true : false;
    saveBtn.textContent = "Save to Timeline";
    saveHint.textContent = (out.style.display === "none") ? "Generate output first. Then save." : "Ready. Save this memory to your timeline.";
  } else {
    statusDot.classList.remove("green"); statusDot.classList.add("red");
    sessionText.textContent = "Guest (locked)";
    lockBtn.style.display = "none";
    tabTimeline.disabled = true;
    saveBtn.disabled = true;
    saveBtn.textContent = "Save to Timeline (Locked)";
    saveHint.textContent = "Generate output first. Then unlock to save.";
  }
}

/* =========================================================
   HARD RESET (prevents visual leaks across users)
========================================================= */
function stopCamera(){
  try{
    if (stream) stream.getTracks().forEach(t => t.stop());
  }catch(_){}
  stream = null;
  try{ video.srcObject = null; }catch(_){}
  startBtn.disabled = false;
  startBtn.textContent = "Start Camera";
  flipBtn.disabled = true;
  shootBtn.disabled = true;
  retakeBtn.disabled = true;
}

function hardResetBoothUI(){
  // Hide any generated output (no one should see previous person's card)
  out.style.display = "none";
  video.style.display = "block";

  // Clear shots + thumbs
  shots = [];
  thumbs.innerHTML = "";

  // Clear all identity fields
  captionInp.value = "";
  peopleInput.value = "";
  placeLabel.value = "";

  // Clear GPS state
  geoData = null;
  geoStatus.textContent = "GPS: not captured";

  // Disable actions until new photos are taken
  makeBtn.disabled = true;
  downloadBtn.disabled = true;
  printBtn.disabled = true;

  // Save always locked unless unlocked + output exists
  saveBtn.disabled = true;

  // Hide countdown
  countdownEl.style.display = "none";

  // Optional: reset look defaults
  // strengthInp.value = 65;
  // grainInp.value = 35;
  // datestampSel.value = "on";
}

/* =========================================================
   Auto-lock (idle + tab hidden)
========================================================= */
let idleTimer = null;
const IDLE_MS = 60000;

function resetIdle(){
  if (!isUnlocked()) return;
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => {
    lockNow();
    alert("Locked due to inactivity.");
  }, IDLE_MS);
}
["click","mousemove","keydown","touchstart","scroll"].forEach(ev => {
  window.addEventListener(ev, () => resetIdle(), { passive:true });
});
document.addEventListener("visibilitychange", () => {
  if (document.hidden && isUnlocked()){
    lockNow();
  }
});

/* =========================================================
   Camera
========================================================= */
let stream = null;
let facingMode = "user";
let shots = [];

async function startCamera(){
  if (stream) stream.getTracks().forEach(t => t.stop());
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  flipBtn.disabled = false;
  shootBtn.disabled = false;
  retakeBtn.disabled = false;
  startBtn.textContent = "Camera On";
  startBtn.disabled = true;
}

function captureFrame(){
  const c = document.createElement('canvas');
  const w = video.videoWidth, h = video.videoHeight;
  c.width = w; c.height = h;
  const cctx = c.getContext('2d');
  if (facingMode === "user"){
    cctx.translate(w, 0);
    cctx.scale(-1, 1);
  }
  cctx.drawImage(video, 0, 0, w, h);
  return c.toDataURL('image/jpeg', 0.92);
}
function renderThumbs(){
  thumbs.innerHTML = "";
  shots.forEach((src) => {
    const div = document.createElement('div');
    div.className = "thumb";
    const img = document.createElement('img');
    img.src = src;
    div.appendChild(img);
    thumbs.appendChild(div);
  });
}
async function countdown(n=3){
  countdownEl.style.display = "block";
  for (let i=n; i>=1; i--){
    countdownEl.textContent = i;
    await sleep(650);
  }
  countdownEl.textContent = "✦";
  await sleep(220);
  countdownEl.style.display = "none";
}
function resetToCamera(){
  out.style.display="none";
  video.style.display="block";
  downloadBtn.disabled = true;
  printBtn.disabled = true;
  saveBtn.disabled = true;
  setSessionUI();
}
async function takeBurst(){
  resetToCamera();
  shots = [];
  renderThumbs();
  makeBtn.disabled = true;

  for (let i=0; i<3; i++){
    await countdown(3);
    shots.push(captureFrame());
    renderThumbs();
    await sleep(350);
  }
  makeBtn.disabled = false;
}

/* =========================================================
   GPS
========================================================= */
async function getGeo(){
  return new Promise((resolve) => {
    if (!navigator.geolocation) return resolve(null);
    navigator.geolocation.getCurrentPosition(
      (pos) => resolve({
        lat: +pos.coords.latitude.toFixed(6),
        lng: +pos.coords.longitude.toFixed(6),
        accuracy_m: Math.round(pos.coords.accuracy || 0),
      }),
      () => resolve(null),
      { enableHighAccuracy: true, timeout: 9000, maximumAge: 60000 }
    );
  });
}

/* =========================================================
   Drawing helpers
========================================================= */
function addGrain(imageData, amount){
  const d = imageData.data;
  const a = amount / 100;
  const noise = 28 * a;
  for (let i=0; i<d.length; i+=4){
    const n = (Math.random() - 0.5) * noise;
    d[i]   = Math.min(255, Math.max(0, d[i]   + n));
    d[i+1] = Math.min(255, Math.max(0, d[i+1] + n));
    d[i+2] = Math.min(255, Math.max(0, d[i+2] + n));
  }
  return imageData;
}
function vintageGrade(imageData, strength){
  const d = imageData.data;
  const s = strength / 100;
  for (let i=0; i<d.length; i+=4){
    let r = d[i], g = d[i+1], b = d[i+2];

    r = r + (18 * s);
    g = g + (12 * s);
    b = b + (7  * s);

    r = r + (24 * s);
    b = b - (14 * s);

    const mid = 128;
    r = mid + (r - mid) * (1 - 0.18*s);
    g = mid + (g - mid) * (1 - 0.18*s);
    b = mid + (b - mid) * (1 - 0.18*s);

    const gray = 0.299*r + 0.587*g + 0.114*b;
    r = r*(1-0.22*s) + gray*(0.22*s);
    g = g*(1-0.22*s) + gray*(0.22*s);
    b = b*(1-0.22*s) + gray*(0.22*s);

    d[i]   = Math.min(255, Math.max(0, r));
    d[i+1] = Math.min(255, Math.max(0, g));
    d[i+2] = Math.min(255, Math.max(0, b));
  }
  return imageData;
}
function drawRoundedRect(ctx, x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}
function drawCover(ctx, img, x,y,w,h, radius=0){
  const iw = img.width, ih = img.height;
  const tr = w/h, ir = iw/ih;
  let sx=0, sy=0, sw=iw, sh=ih;
  if (ir > tr){ sw = ih*tr; sx=(iw-sw)/2; }
  else { sh = iw/tr; sy=(ih-sh)/2; }

  ctx.save();
  if (radius>0){
    drawRoundedRect(ctx, x,y,w,h,radius);
    ctx.clip();
  } else {
    ctx.beginPath();
    ctx.rect(x,y,w,h);
    ctx.clip();
  }
  ctx.drawImage(img, sx, sy, sw, sh, x,y,w,h);
  const data = ctx.getImageData(x,y,w,h);
  ctx.putImageData(addGrain(vintageGrade(data, +strengthInp.value), +grainInp.value), x,y);
  ctx.restore();
}
function drawDateStamp(ctx, x, y){
  const d = new Date();
  const stamp = d.toLocaleDateString(undefined, { year:"numeric", month:"2-digit", day:"2-digit" });
  ctx.save();
  ctx.textAlign="right";
  ctx.fillStyle="rgba(0,0,0,.55)";
  ctx.font="800 30px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText(stamp, x, y);
  ctx.restore();
}
async function toImages(dataUrls){
  const imgs = [];
  for (const s of dataUrls){
    const im = new Image();
    im.src = s;
    await im.decode();
    imgs.push(im);
  }
  return imgs;
}

/* =========================================================
   Templates
========================================================= */
function templateStrip(imgs, caption, withDate){
  out.width = 1200; out.height = 2400;
  const W = out.width, H = out.height;

  ctxOut.clearRect(0,0,W,H);
  ctxOut.fillStyle = "#fbf6eb";
  ctxOut.fillRect(0,0,W,H);

  const pad = 160;
  const frameW = W - pad*2;
  const frameH = 520;
  const gap = 60;
  const top = 170;

  ctxOut.fillStyle="#ffffff";
  ctxOut.fillRect(pad-24, top-24, frameW+48, (frameH*3 + gap*2)+48);

  for(let i=0;i<3;i++){
    drawCover(ctxOut, imgs[i], pad, top + i*(frameH+gap), frameW, frameH, 18);
    ctxOut.strokeStyle="rgba(0,0,0,.08)";
    ctxOut.lineWidth=3;
    ctxOut.strokeRect(pad, top + i*(frameH+gap), frameW, frameH);
  }

  ctxOut.fillStyle="#1a1a1a";
  ctxOut.font="900 54px ui-serif, Georgia, 'Times New Roman', serif";
  ctxOut.textAlign="left";
  ctxOut.fillText(caption || "—", pad-10, top + frameH*3 + gap*2 + 160);

  ctxOut.fillStyle="rgba(26,26,26,.62)";
  ctxOut.font="400 30px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctxOut.fillText("photo strip", pad-10, top + frameH*3 + gap*2 + 210);

  if (withDate) drawDateStamp(ctxOut, W - pad + 10, H - 140);
}
function templatePostcard3(imgs, caption, withDate){
  out.width = 1600; out.height = 1100;
  const W = out.width, H = out.height;

  ctxOut.clearRect(0,0,W,H);
  ctxOut.fillStyle="#fbf6eb";
  ctxOut.fillRect(0,0,W,H);

  const pad = 70;
  const leftW = Math.floor(W*0.58);

  const collageX = pad, collageY = pad, collageW = leftW - pad*1.2, collageH = H - pad*2;
  ctxOut.fillStyle="#ffffff";
  ctxOut.fillRect(collageX-18, collageY-18, collageW+36, collageH+36);

  const gap = 26;
  const cellH = Math.floor((collageH - gap*2)/3);
  for(let i=0;i<3;i++){
    drawCover(ctxOut, imgs[i], collageX, collageY + i*(cellH+gap), collageW, cellH, 16);
    ctxOut.strokeStyle="rgba(0,0,0,.08)";
    ctxOut.lineWidth=3;
    ctxOut.strokeRect(collageX, collageY + i*(cellH+gap), collageW, cellH);
  }

  const rightX = leftW + 20;

  ctxOut.fillStyle="rgba(26,26,26,.70)";
  ctxOut.font="900 46px ui-serif, Georgia, 'Times New Roman', serif";
  ctxOut.textAlign="left";
  ctxOut.fillText(caption || "Greetings", rightX, pad + 70);

  ctxOut.fillStyle="rgba(26,26,26,.55)";
  ctxOut.font="400 26px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctxOut.fillText("Wish you were here.", rightX, pad + 112);

  ctxOut.strokeStyle="rgba(0,0,0,.12)";
  ctxOut.lineWidth=4;
  ctxOut.beginPath();
  ctxOut.moveTo(leftW+10, pad);
  ctxOut.lineTo(leftW+10, H-pad);
  ctxOut.stroke();

  const linesX = rightX;
  const linesY = pad + 200;
  ctxOut.strokeStyle="rgba(0,0,0,.14)";
  ctxOut.lineWidth=3;
  for(let i=0;i<6;i++){
    ctxOut.beginPath();
    ctxOut.moveTo(linesX, linesY + i*90);
    ctxOut.lineTo(W - pad, linesY + i*90);
    ctxOut.stroke();
  }

  if (withDate) drawDateStamp(ctxOut, W - pad, H - 70);
}
function templateFilm3(imgs, caption, withDate){
  out.width = 1600; out.height = 2200;
  const W = out.width, H = out.height;

  ctxOut.clearRect(0,0,W,H);
  ctxOut.fillStyle="#0f0f0f";
  ctxOut.fillRect(0,0,W,H);

  const pad = 170;
  const filmX = pad, filmY = 160, filmW = W - pad*2, filmH = H - 320;

  ctxOut.fillStyle="#141414";
  ctxOut.fillRect(filmX, filmY, filmW, filmH);

  function sprockets(x){
    const holeW = 60, holeH = 44;
    const gap = 26;
    const top = filmY + 70;
    const count = Math.floor((filmH - 140) / (holeH + gap));
    ctxOut.fillStyle="#0b0b0b";
    for(let i=0;i<count;i++){
      const y = top + i*(holeH+gap);
      drawRoundedRect(ctxOut, x, y, holeW, holeH, 10);
      ctxOut.fill();
    }
  }
  sprockets(filmX + 32);
  sprockets(filmX + filmW - 32 - 60);

  const innerX = filmX + 120;
  const innerW = filmW - 240;
  const frameH = 470;
  const gapY = 90;
  const startY = filmY + 120;

  for(let i=0;i<3;i++){
    const x = innerX;
    const y = startY + i*(frameH+gapY);
    ctxOut.fillStyle="#000";
    ctxOut.fillRect(x-18, y-18, innerW+36, frameH+36);
    drawCover(ctxOut, imgs[i], x, y, innerW, frameH, 8);

    ctxOut.fillStyle="rgba(255,255,255,.55)";
    ctxOut.font="700 26px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctxOut.fillText("KODAK 400", filmX + 120, y - 40);
    ctxOut.textAlign="right";
    ctxOut.fillText(String(i+1).padStart(2,"0"), filmX + filmW - 120, y - 40);
    ctxOut.textAlign="left";
  }

  ctxOut.fillStyle="#fbf6eb";
  ctxOut.fillRect(0,0,W,140);
  ctxOut.fillStyle="#1a1a1a";
  ctxOut.font="900 54px ui-serif, Georgia, 'Times New Roman', serif";
  ctxOut.textAlign="left";
  ctxOut.fillText(caption || "—", 90, 92);

  if (withDate) drawDateStamp(ctxOut, W - 90, 92);
}

/* =========================================================
   Generate
========================================================= */
async function generate(){
  if (shots.length !== 3) return;

  const imgs = await toImages(shots);
  const caption = captionInp.value.trim();
  const withDate = datestampSel.value === "on";
  const t = templateSel.value;

  if (t === "strip") templateStrip(imgs, caption, withDate);
  if (t === "postcard3") templatePostcard3(imgs, caption, withDate);
  if (t === "film3") templateFilm3(imgs, caption, withDate);

  out.style.display = "block";
  video.style.display = "none";
  downloadBtn.disabled = false;
  printBtn.disabled = false;

  setSessionUI();
}

/* =========================================================
   Download / Print
========================================================= */
function download(){
  const link = document.createElement('a');
  link.download = "vintage_template.jpg";
  link.href = out.toDataURL("image/jpeg", 0.92);
  link.click();
}
function printCard(){
  const dataUrl = out.toDataURL("image/jpeg", 0.92);
  const w = window.open("", "_blank");
  w.document.write(`<img src="${dataUrl}" style="width:100%;max-width:900px;display:block;margin:20px auto;">`);
  w.document.write(`<script>window.onload=()=>{window.print();};<\/script>`);
  w.document.close();
}

/* =========================================================
   People suggestions (from decrypted events)
========================================================= */
function buildPeopleSuggestions(allPeople){
  const unique = Array.from(new Set(allPeople.map(p => p.trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
  peopleSuggestions.innerHTML = "";
  unique.slice(0, 18).forEach(name => {
    const b = document.createElement("button");
    b.className = "chip";
    b.type = "button";
    b.textContent = name;
    b.onclick = () => {
      const current = sanitizePeopleInput(peopleInput.value);
      if (!current.includes(name)) current.push(name);
      peopleInput.value = current.join(", ");
    };
    peopleSuggestions.appendChild(b);
  });
}

async function saveMemory(){
  if (!isUnlocked()) return;
  if (out.style.display === "none") return;

  const people = sanitizePeopleInput(peopleInput.value);
  const place = (placeLabel.value || "").trim() || null;

  const finalDataURL = canvasToDataURL(out, 0.92);

  const tCanvas = document.createElement("canvas");
  const maxW = 520;
  const ratio = out.height / out.width;
  tCanvas.width = maxW;
  tCanvas.height = Math.round(maxW * ratio);
  const tctx = tCanvas.getContext("2d");
  tctx.drawImage(out, 0, 0, tCanvas.width, tCanvas.height);
  const thumbDataURL = canvasToDataURL(tCanvas, 0.86);

  const payload = {
    createdAt: nowISO(),
    template: templateSel.value,
    caption: (captionInp.value || "").trim() || null,
    people,
    placeLabel: place,
    geo: geoData,
    finalDataURL,
    thumbDataURL
  };

  const enc = await encryptJSON(sessionKey, payload);

  const event = {
    id: crypto.randomUUID(),
    profileId: activeProfileId,
    createdAt: payload.createdAt,
    enc
  };

  await dbPut(STORE_EVENTS, event);

  saveHint.textContent = "Saved to your vault.";
  await refreshPeopleSources();

  // OPTIONAL: after saving, wipe booth so next user sees clean screen
  hardResetBoothUI();
}

/* =========================================================
   Timeline: decrypt + filter + render
========================================================= */
let lastObjectURLs = [];
function revokeAllObjectURLs(){
  lastObjectURLs.forEach(u => { try{ URL.revokeObjectURL(u); }catch(e){} });
  lastObjectURLs = [];
}

function templateLabel(t){
  if (t === "strip") return "Photo Strip";
  if (t === "postcard3") return "Postcard Collage";
  if (t === "film3") return "Film Border";
  return t || "Template";
}

async function getMyEventsEncrypted(){
  const all = await dbGetAll(STORE_EVENTS);
  return all.filter(e => e.profileId === activeProfileId);
}

async function decryptMany(encEvents){
  const outArr = [];
  for (const e of encEvents){
    try{
      const payload = await decryptJSON(sessionKey, e.enc.ivB64, e.enc.ctB64);
      outArr.push({ id:e.id, profileId:e.profileId, createdAt:e.createdAt, payload });
    } catch(_){}
  }
  return outArr;
}

function collectAllPeopleFromDecrypted(items){
  const all = [];
  items.forEach(x => (x.payload.people || []).forEach(p => all.push(p)));
  return all;
}

async function refreshPeopleSources(){
  if (!isUnlocked()) { buildPeopleSuggestions([]); return; }
  const enc = await getMyEventsEncrypted();
  const dec = await decryptMany(enc);
  buildPeopleSuggestions(collectAllPeopleFromDecrypted(dec));
}

/* =========================================================
   Map + Heat
========================================================= */
let currentView = "list";
let mapInstance = null;
let clusterLayer = null;
let heatLayer = null;
let mapBuilt = false;

function setViewButtonUI(){
  const setDim = (btn, on) => btn.style.opacity = on ? "1" : ".7";
  setDim(viewListBtn, currentView === "list");
  setDim(viewPinsBtn, currentView === "pins");
  setDim(viewHeatBtn, currentView === "heat");
}
function showListView(){
  currentView = "list";
  timelineGrid.style.display = "";
  mapWrap.style.display = "none";
  setViewButtonUI();
}
function showMapWrap(){
  timelineGrid.style.display = "none";
  mapWrap.style.display = "";
  setTimeout(() => { if (mapInstance) mapInstance.invalidateSize(); }, 60);
}
function ensureMap(){
  if (mapBuilt) return;
  mapBuilt = true;

  mapInstance = L.map(mapEl, { zoomControl:true }).setView([20.5937, 78.9629], 5);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap"
  }).addTo(mapInstance);

  clusterLayer = L.markerClusterGroup({
    showCoverageOnHover: false,
    spiderfyOnMaxZoom: true,
    disableClusteringAtZoom: 17
  });
}
function clearMapLayers(){
  if (!mapInstance) return;
  if (clusterLayer && mapInstance.hasLayer(clusterLayer)) mapInstance.removeLayer(clusterLayer);
  if (heatLayer && mapInstance.hasLayer(heatLayer)) mapInstance.removeLayer(heatLayer);
  if (clusterLayer) clusterLayer.clearLayers();
  heatLayer = null;
}
function fitToBounds(points){
  if (!mapInstance || points.length === 0) {
    if (mapInstance) mapInstance.setView([20.5937, 78.9629], 5);
    return;
  }
  const b = L.latLngBounds(points);
  mapInstance.fitBounds(b, { padding:[30,30] });
}
function jumpToMemoryInList(targetId){
  showListView();
  const el = document.querySelector(`[data-card-id="${targetId}"]`);
  if (el){
    el.scrollIntoView({ behavior:"smooth", block:"center" });
    el.style.outline = "3px solid rgba(106,75,47,.35)";
    setTimeout(() => { el.style.outline = ""; }, 1200);
  }
}
function buildPins(decryptedItems){
  ensureMap();
  clearMapLayers();

  const gps = decryptedItems.filter(x => x.payload.geo && typeof x.payload.geo.lat === "number" && typeof x.payload.geo.lng === "number");

  if (gps.length === 0){
    mapInstance.setView([20.5937, 78.9629], 5);
    return;
  }

  const bounds = [];
  gps.forEach(x => {
    const p = x.payload;
    bounds.push([p.geo.lat, p.geo.lng]);

    const when = fmtDateTime(p.createdAt);
    const people = (p.people || []).slice(0,3).join(", ");
    const place = p.placeLabel ? p.placeLabel : "—";

    const popupHtml = `
      <div style="display:grid; gap:8px; width:220px;">
        <img src="${p.thumbDataURL}" style="width:100%; border-radius:10px; display:block;" />
        <div style="font-weight:800; font-size:12px;">${escapeHtml(when)}</div>
        <div style="color:rgba(0,0,0,.65); font-size:12px; line-height:1.25;">
          ${escapeHtml(place)}<br/>
          <span style="color:rgba(0,0,0,.55);">${escapeHtml(people || "No tags")}</span>
        </div>
        <button data-jump="${x.id}" style="padding:10px 12px;border-radius:12px;border:1px solid rgba(0,0,0,.12);background:#fff;cursor:pointer;">
          Open memory
        </button>
      </div>
    `;

    const marker = L.marker([p.geo.lat, p.geo.lng]).bindPopup(popupHtml);
    marker.on("popupopen", () => {
      const btn = document.querySelector(`button[data-jump="${x.id}"]`);
      if (btn) btn.onclick = () => jumpToMemoryInList(x.id);
    });

    clusterLayer.addLayer(marker);
  });

  clusterLayer.addTo(mapInstance);
  fitToBounds(bounds);
}

function buildHeat(decryptedItems){
  ensureMap();
  clearMapLayers();

  const gps = decryptedItems.filter(x => x.payload.geo && typeof x.payload.geo.lat === "number" && typeof x.payload.geo.lng === "number");

  if (gps.length === 0){
    mapInstance.setView([20.5937, 78.9629], 5);
    return;
  }

  const pts = [];
  const bounds = [];
  gps.forEach(x => {
    const g = x.payload.geo;
    let w = 0.65;
    if (g.accuracy_m && Number.isFinite(g.accuracy_m)){
      const a = clamp(g.accuracy_m, 5, 200);
      w = 1.0 - ((a - 5) / (200 - 5)) * 0.65;
      w = clamp(w, 0.35, 1.0);
    }
    pts.push([g.lat, g.lng, w]);
    bounds.push([g.lat, g.lng]);
  });

  heatLayer = L.heatLayer(pts, { radius: 28, blur: 22, maxZoom: 17 }).addTo(mapInstance);
  fitToBounds(bounds);
}

async function refreshTimelineUI(){
  if (!isUnlocked()) return;

  revokeAllObjectURLs();

  const encEvents = await getMyEventsEncrypted();
  encEvents.sort((a,b) => (b.createdAt||"").localeCompare(a.createdAt||""));
  stats.textContent = `${encEvents.length} memories`;

  const dec = await decryptMany(encEvents);

  const allPeople = collectAllPeopleFromDecrypted(dec);
  const uniquePeople = Array.from(new Set(allPeople.map(x=>x.trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
  const currentPerson = personFilter.value || "";
  personFilter.innerHTML = `<option value="">All people</option>` + uniquePeople.map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join("");
  personFilter.value = currentPerson;

  const pSel = personFilter.value || "";
  const q = (searchFilter.value || "").trim().toLowerCase();

  const filtered = dec.filter(x => {
    const p = x.payload;
    const byPerson = !pSel || (p.people || []).includes(pSel);
    const text = `${p.caption||""} ${p.placeLabel||""} ${(p.people||[]).join(" ")}`.toLowerCase();
    const bySearch = !q || text.includes(q);
    return byPerson && bySearch;
  });

  timelineGrid.innerHTML = "";
  if (filtered.length === 0){
    timelineGrid.innerHTML = `
      <div class="tCard" style="max-width:720px;">
        <div class="tBody">
          <div class="tWhen">No memories found</div>
          <div class="tWhere">Save some memories in this profile.</div>
        </div>
      </div>
    `;
  } else {
    filtered.sort((a,b)=> (b.payload.createdAt||"").localeCompare(a.payload.createdAt||""));
    filtered.forEach(x => {
      const p = x.payload;
      const when = fmtDateTime(p.createdAt);

      const whereParts = [];
      if (p.placeLabel) whereParts.push(p.placeLabel);
      if (p.geo) whereParts.push(`GPS: ${p.geo.lat}, ${p.geo.lng} (±${p.geo.accuracy_m}m)`);
      whereParts.push(templateLabel(p.template));
      const where = whereParts.join(" • ");

      const card = document.createElement("div");
      card.className = "tCard";
      card.setAttribute("data-card-id", x.id);

      card.innerHTML = `
        <div class="tInner">
          <div class="tThumb"><img src="${p.thumbDataURL}" alt="thumb"/></div>
          <div class="tBody">
            <div>
              <div class="tWhen">${escapeHtml(when)}</div>
              <div class="tWhere">${escapeHtml(where || "—")}</div>
            </div>

            <div class="tPeople">
              ${(p.people || []).length ? (p.people || []).map(n => `<span class="pChip">${escapeHtml(n)}</span>`).join("") : `<span class="pChip">No people tags</span>`}
            </div>

            <div class="tActions">
              <button class="mutedBtn" data-open="${x.id}">Open</button>
              <button class="mutedBtn" data-dl="${x.id}">Download</button>
              ${p.geo ? `<button class="mutedBtn" data-map="${x.id}">Map</button>` : ``}
              <button class="dangerBtn" data-del="${x.id}">Delete</button>
            </div>
          </div>
        </div>
      `;

      card.querySelector(`[data-open="${x.id}"]`).onclick = () => {
        modalTitle.textContent = `${when}${p.placeLabel ? " • " + p.placeLabel : ""}`;
        modalImg.src = p.finalDataURL;
        modal.style.display = "flex";
      };
      card.querySelector(`[data-dl="${x.id}"]`).onclick = () => {
        const a = document.createElement("a");
        a.download = `memory_${p.createdAt.replace(/[:.]/g,"-")}.jpg`;
        a.href = p.finalDataURL;
        a.click();
      };
      const mapBtn = card.querySelector(`[data-map="${x.id}"]`);
      if (mapBtn) mapBtn.onclick = async () => {
        currentView = "pins";
        setViewButtonUI();
        showMapWrap();
        buildPins(filtered);
        const target = filtered.find(z => z.id === x.id);
        if (target && target.payload.geo && mapInstance){
          mapInstance.setView([target.payload.geo.lat, target.payload.geo.lng], 16);
        }
      };

      card.querySelector(`[data-del="${x.id}"]`).onclick = async () => {
        await dbDelete(STORE_EVENTS, x.id);
        await refreshTimelineUI();
        await refreshPeopleSources();
      };

      timelineGrid.appendChild(card);
    });
  }

  if (currentView === "pins"){
    showMapWrap();
    buildPins(filtered);
  } else if (currentView === "heat"){
    showMapWrap();
    buildHeat(filtered);
  } else {
    showListView();
  }
}

/* =========================================================
   Tabs
========================================================= */
function showBooth(){
  boothView.style.display = "";
  timelineView.style.display = "none";
  tabBooth.classList.add("active");
  tabTimeline.classList.remove("active");
}
async function showTimeline(){
  if (!isUnlocked()) return;
  boothView.style.display = "none";
  timelineView.style.display = "";
  tabBooth.classList.remove("active");
  tabTimeline.classList.add("active");
  currentView = "list";
  setViewButtonUI();
  await refreshTimelineUI();
}

/* =========================================================
   Profiles (Gate)
========================================================= */
async function listProfiles(){
  const profiles = await dbGetAll(STORE_PROFILES);
  profiles.sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""));
  profilesGrid.innerHTML = "";

  if (profiles.length === 0){
    noProfiles.style.display = "";
    return profiles;
  } else {
    noProfiles.style.display = "none";
  }

  profiles.forEach(p => {
    const btn = document.createElement("button");
    btn.className = "profileBtn";
    btn.type = "button";
    btn.innerHTML = `
      <div>
        <div class="name">${escapeHtml(p.name)}</div>
        <div class="meta">Created: ${new Date(p.createdAt).toLocaleDateString()}</div>
      </div>
      <div class="meta">Unlock</div>
    `;
    btn.onclick = () => unlockProfileFlow(p.id, p.name, p.saltB64, p.verifierB64);
    profilesGrid.appendChild(btn);
  });

  return profiles;
}

function openGate(){
  gate.style.display = "flex";
  createMsg.textContent = "";
  newName.value = "";
  newPin.value = "";
  listProfiles();
}
function closeGate(){
  gate.style.display = "none";
}

async function createProfile(){
  const name = (newName.value || "").trim();
  const pin = (newPin.value || "").trim();

  if (!name){ createMsg.textContent = "Name required."; return; }
  if (!/^\d{4,12}$/.test(pin)){ createMsg.textContent = "PIN must be 4–12 digits."; return; }

  const profiles = await dbGetAll(STORE_PROFILES);
  if (profiles.some(p => (p.name||"").toLowerCase() === name.toLowerCase())){
    createMsg.textContent = "Name already exists.";
    return;
  }

  const salt = randBytes(16);
  const saltB64 = ab2b64(salt.buffer);

  const bits = await deriveBits(pin, saltB64);
  const vhash = await sha256(bits);
  const verifierB64 = ab2b64(vhash);

  const profile = {
    id: crypto.randomUUID(),
    name,
    createdAt: nowISO(),
    saltB64,
    verifierB64,
    iterations: 150000
  };

  await dbPut(STORE_PROFILES, profile);
  createMsg.textContent = "Created. Unlock it from the left.";
  await listProfiles();
}

async function unlockProfileFlow(id, name, saltB64, verifierB64){
  const pin = prompt(`Enter PIN for ${name}:`);
  if (!pin) return;

  if (!/^\d{4,12}$/.test(pin)){
    alert("Invalid PIN format.");
    return;
  }

  const bits = await deriveBits(pin, saltB64);
  const vhash = await sha256(bits);
  const vB64 = ab2b64(vhash);

  if (vB64 !== verifierB64){
    alert("Wrong PIN.");
    return;
  }

  // IMPORTANT: wipe booth UI before switching identity
  hardResetBoothUI();

  sessionKey = await deriveAesKey(pin, saltB64, 150000);
  activeProfileId = id;
  activeProfileName = name;

  closeGate();
  setSessionUI();
  resetIdle();
  await refreshPeopleSources();
}

function lockNow(){
  activeProfileId = null;
  activeProfileName = null;
  sessionKey = null;

  // CRITICAL: wipe any visible photo/output AND stop camera to prevent frozen frame
  hardResetBoothUI();
  stopCamera();

  // force to booth + hide timeline
  showBooth();
  tabTimeline.disabled = true;
  setSessionUI();

  // clear timeline UI
  timelineGrid.innerHTML = "";
  mapWrap.style.display = "none";
  currentView = "list";
  setViewButtonUI();

  if (idleTimer) { clearTimeout(idleTimer); idleTimer = null; }
}

/* =========================================================
   Listeners
========================================================= */
tabBooth.onclick = showBooth;
tabTimeline.onclick = showTimeline;

startBtn.onclick = async () => { await startCamera(); };
flipBtn.onclick = async () => {
  facingMode = (facingMode === "user") ? "environment" : "user";
  startBtn.disabled = false;
  startBtn.textContent = "Restart Camera";
  await startCamera();
};
shootBtn.onclick = async () => { await takeBurst(); };
retakeBtn.onclick = async () => { await takeBurst(); };
makeBtn.onclick = async () => { await generate(); };
downloadBtn.onclick = download;
printBtn.onclick = printCard;

geoBtn.onclick = async () => {
  geoStatus.textContent = "GPS: capturing…";
  geoData = await getGeo();
  if (!geoData){
    geoStatus.textContent = "GPS: denied/unavailable";
    geoData = null;
  } else {
    geoStatus.textContent = `GPS: ${geoData.lat}, ${geoData.lng} (±${geoData.accuracy_m}m)`;
  }
};

saveBtn.onclick = async () => {
  if (!isUnlocked()) return;
  saveBtn.disabled = true;
  await saveMemory();
  saveBtn.disabled = false;
  resetIdle();
};

viewListBtn.onclick = async () => { currentView = "list"; setViewButtonUI(); await refreshTimelineUI(); };
viewPinsBtn.onclick = async () => { currentView = "pins"; setViewButtonUI(); await refreshTimelineUI(); };
viewHeatBtn.onclick = async () => { currentView = "heat"; setViewButtonUI(); await refreshTimelineUI(); };

refreshTimeline.onclick = async () => { if (isUnlocked()) await refreshTimelineUI(); };
personFilter.onchange = async () => { if (isUnlocked()) await refreshTimelineUI(); };
searchFilter.oninput = async () => { if (isUnlocked()) await refreshTimelineUI(); };

clearAll.onclick = async () => {
  if (!isUnlocked()) return;
  const ok = confirm(`Clear ALL memories for ${activeProfileName}?`);
  if (!ok) return;
  await dbClearWhereProfile(activeProfileId);
  await refreshTimelineUI();
  await refreshPeopleSources();
};

modalClose.onclick = () => { modal.style.display = "none"; };
modal.onclick = (e) => { if (e.target === modal) modal.style.display = "none"; };

// Switch profile MUST reset booth before showing gate
switchProfileBtn.onclick = () => {
  hardResetBoothUI();
  openGate();
};

lockBtn.onclick = () => lockNow();

// Continue as Guest MUST lock + reset everything
gateClose.onclick = () => {
  lockNow();
  closeGate();
};

createProfileBtn.onclick = async () => { await createProfile(); };

/* =========================================================
   Boot
========================================================= */
(async function init(){
  setViewButtonUI();
  setSessionUI();

  // Start clean
  hardResetBoothUI();
  stopCamera();

  // Gate first
  openGate();
})();
</script>
</body>
</html>
